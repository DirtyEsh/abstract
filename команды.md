Ниже — прикладной “шпаргалочник” без теории. Команды + типовые сценарии. Копируй как есть.

---

## 1) Первый раз: клонировать и начать работать

```bash
git clone git@github.com:YOU/repo.git
cd repo
git status
```

---

## 2) Ежедневный цикл: сделал изменения → запушил

```bash
git status
git add -A
git commit -m "Meaningful message"
git push
```

Если пушишь первый раз и git просит upstream:

```bash
git push -u origin main
```

---

## 3) “Подтянуть с GitHub” (самое частое)

### Вариант простой (fetch+merge одной командой)

```bash
git pull
```

### Вариант безопаснее (сначала посмотреть что приехало)

```bash
git fetch
git status
git log --oneline --decorate --graph --all -n 20
git merge origin/main
```

---

## 4) Работа через ветку (нормально для командной разработки)

### Создать ветку и переключиться

```bash
git switch -c feature/model-fix
```

### Пушить свою ветку

```bash
git push -u origin feature/model-fix
```

### Подтягивать main в свою ветку (чтобы не отстать)

**merge-вариант:**

```bash
git fetch origin
git merge origin/main
```

**rebase-вариант (часто лучше для личной ветки):**

```bash
git fetch origin
git rebase origin/main
```

Если конфликт:

```bash
# правишь файлы
git add -A
git rebase --continue
# если всё плохо
git rebase --abort
```

---

## 5) “Смержить мою ветку в main” (локально)

Если вы без PR и ты хочешь влить feature в main:

```bash
git switch main
git pull
git merge feature/model-fix
git push
```

---

## 6) Конфликт при merge: что делать (типовой рецепт)

Git скажет CONFLICT. Дальше:

1. Посмотреть конфликтные файлы:
    

```bash
git status
```

2. Открыть файл и убрать маркеры:
    

```cpp
<<<<<<< HEAD
твоя версия
=======
их версия
>>>>>>> origin/main
```

3. Отметить как решённое и завершить merge:
    

```bash
git add -A
git commit
git push
```

Если хочешь отменить merge и вернуться как было:

```bash
git merge --abort
```

---

## 7) “Я накосячил” — быстрые спасалки

### Отменить изменения в файле (не закоммичено)

```bash
git restore file.cpp
```

### Убрать файл из staging (после git add)

```bash
git restore --staged file.cpp
```

### Откатить последний коммит, но оставить файлы

```bash
git reset --soft HEAD~1
```

### Откатить последний коммит и изменения в файлах (жёстко)

```bash
git reset --hard HEAD~1
```

### Вернуть рабочую копию как в последнем коммите

```bash
git reset --hard
```

---

## 8) Посмотреть “что вообще происходит”

### Лог красиво

```bash
git log --oneline --graph --decorate --all -n 30
```

### Разница (что изменил)

```bash
git diff
```

### Разница в staging

```bash
git diff --staged
```

---

## 9) Твой кейс с template (Практикум): подтянуть обновления задач

Один раз добавить remote:

```bash
git remote add -m main template git@github.com:cpppracticum/cpp-qt-template-practicum-2025.git
```

Обновить конкретную папку из шаблона:

```bash
git fetch template
git checkout template/main -- problems/sprint2/final-task
```

---

## 10) Мини-набор “на каждый день”

```bash
git status
git pull
git add -A
git commit -m "msg"
git push
```

---

Хочешь — я дам тебе 3 готовых “скрипта-рутины” под разные режимы:

1. один работаешь в main (конспекты/учёба)
    
2. работаешь с ветками (командный режим)
    
3. работаешь с template (Практикум)