Ок, делаем **коротко, жёстко, по сути**, без лишних связей.

---

# Компараторы — короткий конспект

## Что такое компаратор

Компаратор — это функция (или лямбда), которая отвечает на вопрос:

> **`a` должен идти раньше `b`?**

Сигнатура:

```cpp
bool comp(const T& a, const T& b);
```

- `true` → `a` раньше `b`
    
- `false` → `a` не раньше `b`
    

---

## Как `std::sort` использует компаратор

`std::sort` **не проверяет равенство**.  
Он многократно задаёт **только один вопрос**:

```cpp
comp(a, b)?
```

Если компаратор “кривой” → сортировка ломается (UB).

---

## Почему нельзя `<=`, `>=`, `==` в `sort`

### Требование `std::sort`

Компаратор должен задавать **строгий порядок**.

### Что это значит на практике

❌ ПЛОХО:

```cpp
[](int a, int b) { return a <= b; }
```

Почему:

```cpp
a <= a  → true   // запрещено
```

Компаратор **никогда** не должен говорить, что элемент меньше самого себя.

---

### Минимальные правила для компаратора

```cpp
comp(a, a) == false        // всегда
comp(a, b) == !comp(b, a) // не одновременно true
```

Этому **соответствует только `<` или `>`**.

---

## Какие STL-компараторы МОЖНО в `sort`

```cpp
std::less<T>      // a < b   ✅
std::greater<T>   // a > b   ✅
```

## Какие НЕЛЬЗЯ

```cpp
std::less_equal<T>      // a <= b  ❌
std::greater_equal<T>  // a >= b  ❌
std::equal_to<T>       // a == b  ❌
```

Причина одна: **нарушают строгий порядок**.

---

## Лямбда-компаратор — основной вариант

```cpp
std::sort(v.begin(), v.end(),
    [](int a, int b) {
        return a < b;
    });
```

### Что передаётся в лямбду

- `a` и `b` — **два элемента контейнера**
    
- ты отвечаешь: **a раньше b?**
    

---

## Пользовательские типы (коротко)

```cpp
struct Person {
    QString name;
    int age;
};
```

```cpp
std::sort(people.begin(), people.end(),
    [](const Person& a, const Person& b) {
        return a.age < b.age;
    });
```

---

## Qt и регистр

```cpp
std::sort(strings.begin(), strings.end(),
    [](const QString& a, const QString& b) {
        return QString::compare(a, b, Qt::CaseInsensitive) < 0;
    });
```

Почему `< 0`?  
`QString::compare` возвращает:

- `< 0` → `a < b`
    
- `0` → равны
    
- `> 0` → `a > b`
    

---

## Где тут `operator<` и почему он вообще существует

- `operator<` — **дефолтное правило сравнения типа**
    
- `std::sort` **использует его**, если компаратор не передан
    

```cpp
std::sort(v.begin(), v.end()); // использует operator<
```

Компаратор — это **локальная альтернатива**, когда:

- нельзя менять тип
    
- нужно другое правило
    
- нужен режим (по весу / имени / без регистра)
    

---

## Ультра-выжимка

- `sort` спрашивает только: **a раньше b?**
    
- Компаратор → `bool`
    
- Разрешено: `<`, `>`
    
- Запрещено: `<=`, `>=`, `==`
    
- `std::less / greater` — OK
    
- Лямбда — основной инструмент
    
- Qt: `QString::compare(...) < 0`
    

Если нужно — дальше логично разобрать:  
**как компаратор ломает `lower_bound`** или **чем `stable_sort` реально отличается**.