Qt-версия словаря `QMap` — аналог std::[[map]]. Ключи в этих словарях уникальны и упорядочены идентично. Как и `std::map`, Qt-версия словаря обладает методами:

- `empty()` — проверить словарь на пустоту;
- `size()` — вернуть количество записей;
- `contains(ключ)` — узнать, есть ли запись с заданным значением ключа;
- `find(ключ)` — вернуть итератор на элемент.
  
  ### Добавление записей

Как у стандартного словаря, у `QMap` есть метод `insert`. Однако элемент при вставке передаётся не как пара (`std::pair`), а двумя параметрами: ключом и значением. На примере для словаря «число-строка» это выглядит так:

```
std::map<int, std::string> std_map;
std_map.insert( {1, "1"} );

QMap<int, QString> q_map;
q_map.insert(1, "1"); 
```

В примере выше в словари вставляется пара с ключом «1» и значением «1». Теперь повторим эти операции с теми же ключами, но другими значениями.

```
std_map.insert( {1, "2"} );
std::cout << std_map[1] << std::endl; 
// Вывод: 1 — значение осталось прежним.

q_map.insert(1, "2");
std::cout << q_map[1] << std::endl; 
// Вывод: 2 — значение обновилось. 
```
### Особенности чтения

Пройдёмся по элементам словарей с помощью итераторов. Стандартный словарь `std::map` позволяет получить ключ и значение как элементы `std::pair`. У итератора `QMap` для этого есть два удобных метода — `key()` и `value()`. Разыменование итератора возвращает значение.

Посмотрим на примере:

```
for (auto it = std_map.begin(); it != std_map.end(); ++it) {
    std::cout << it->first << " " << it->second << std::endl;
}

for (auto it = q_map.begin(); it != q_map.end(); ++it) {
    // Вариант 1: использование методов key() и value():
    std::cout << it.key() << " " << it.value() << std::endl;
    // Вариант 2 (если ключ не нужен, а достаточно значения). 
    // Разыменование итератора:
    std::cout << *it << std::endl;
} 
```

При использовании range-based-цикла с `QMap` можно вывести все значения:

```
for (const auto& value : q_map) {
    std::cout << value << std::endl;
} 
```

### Удаление элементов

Метод `erase` в `QMap` удаляет элемент **только по итератору**, для удаления по ключу нужно использовать метод `remove`. Два варианта удаления ключа «1»:

```
// Вариант 1:
q_map.erase(q_map.find(1));

// Вариант 2:
q_map.remove(1); 
```

Финализируя сравнение `QMap` и `std::map`, отметим, что эти контейнеры имеют идентичные методы `empty()`, `size()`, `contains(ключ)` и `find(ключ)`. При этом в `QMap` есть и свой метод проверки словаря на пустоту — `isEmpty()`. По-разному работают методы записи, чтения и удаления элементов.

Чтобы получить `std::map` из `QMap`, можно воспользоваться методом `toStdMap()`.

```
std::map<int, std::string> std_map = q_map.toStdMap(); 
```