Формальное определение
[[lambda]]
[[algorithm]]

=============================
Ниже — **структурированный конспект в Markdown**.  
Смысл сохранён, мусор вычищен, логика выровнена, добавлено минимально и по делу.

---

# Итераторы в C++ — ридбук

## Формальное определение

**Итератор** — объект, обобщающий указатель, который позволяет работать с контейнерами единообразно.

> _“Iterators are a generalization of pointers…”_  
> — ISO/IEC 14882:2020


---

## Базовые факты (коротко)

```
vec.begin() → первый элемент
vec.end()   → последний + 1 (фиктивный, пустой)
```

- `end()` — **эквивалент `nullptr` для итераторов**
    
- `*`, `->`, `++`, `--`, `+`, `-` — работают (в зависимости от категории)
    
- `student_iter->GetAvgScore()` — обычный и правильный синтаксис
    

---

## Получение итератора

```cpp
std::vector<std::string> client_names = {"Bill", "Jeff", "Mark"};

auto iter = client_names.begin();
// тип: std::vector<std::string>::iterator
```

---

## Доступ к элементу

### Разыменование `*`

```cpp
std::string name = *iter;
std::cout << *iter << std::endl;
PayRoyalty(*iter);
```

> `*` — операция **разыменования**

### Изменение элемента

```cpp
*iter = "Elon";
```

---

## Объекты и структуры

```cpp
auto student_iter = students.begin();
auto point_iter   = points.begin();

(*student_iter).GetAvgScore();
(*point_iter).x;
```

Эквивалентная и **предпочтительная** форма:

```cpp
student_iter->GetAvgScore();
point_iter->x;
```

---

## Итератор `end()`

- `end()` **не указывает на элемент**
    
- разыменовывать нельзя
    
- можно сравнивать
    
- можно двигать **влево**
    

```cpp
auto last = v.end() - 1;
std::cout << *last; // OK
```

Для пустого контейнера:

```cpp
begin() == end()
```

---

## Перемещение итераторов

### `++` и `--`

```cpp
++iter; // следующий
--iter; // предыдущий
```

---

### Арифметика (RandomAccessIterator)

```cpp
iter += 3;
iter -= 2;

auto it2 = iter + 1;
auto it3 = iter - 1;
```

---

## `advance`, `next`, `prev`

Работают **с любыми итераторами**:

```cpp
std::advance(iter, 2);
auto it2 = std::next(iter);
auto it3 = std::prev(iter);
```

---

## Итератор как индекс

```cpp
auto it = numbers.begin() + 4; // 5-й элемент
```

⚠️ Только если контейнер поддерживает random access (`vector`, `deque`).

---

## Расстояние между итераторами

```cpp
int d = iter2 - iter; // может быть отрицательным
```

Эквивалент:

```cpp
std::distance(iter, iter2);
```

---

## Константные итераторы

```cpp
std::vector<T>::const_iterator it = vec.begin();
```

- нельзя менять элементы
    
- но можно читать
    

### `cbegin()` / `cend()`

```cpp
auto it = vec.cbegin();
auto end = vec.cend();
```

> Буква **`c` = const**

Если контейнер `const`, других итераторов не будет.

---

## Реверсивные итераторы

```cpp
for (auto it = v.rbegin(); it != v.rend(); ++it) {
    std::cout << *it;
}
```

- `rbegin()` → последний элемент
    
- `rend()` → фиктивный перед первым
    
- `++` идёт **назад**
    

---

## Диапазоны

```
[v.begin(), v.end())     → прямой порядок
[v.rbegin(), v.rend())   → обратный порядок
```

---

## Range-based for

```cpp
for (const auto& x : v) {
    std::cout << x;
}
```

- использует итераторы
    
- по эффективности = обычный `for`
    

---

## Вставка по итератору

```cpp
auto it = ++names.begin(); // перед Jeff
names.insert(it, "Elon");
```

`insert` возвращает итератор на вставленный элемент.

---

## Удаление по итератору

```cpp
names.erase(it);
```

---

## Инвалидация итераторов

### Инвалидируют:

- `insert`
    
- `erase`
    
- `push_back`
    
- `pop_back`
    
- `clear`
    
- `reserve`
    
- `resize`
    

### НЕ инвалидируют:

- `size()`, `empty()`
    
- `begin()`, `end()`, `cbegin()`, `rbegin()`
    
- чтение/изменение через `*it`, `[]`, `at()`
    

---

## Реаллокация — ключевая причина

### Что происходит

1. `vector` хранит данные в одном буфере
    
2. если `capacity()` не хватает:
    
    - выделяется новый буфер
        
    - элементы копируются
        
    - старый удаляется
        

### Главное правило

> **Итератор инвалидируется, если**
> 
> 1. элемент удалён
>     
> 2. произошла реаллокация памяти
>     

После этого итераторы **обязаны быть получены заново**.

---

## Финальная выжимка

```
begin / end — границы диапазона
end — фиктивный элемент
* / -> — доступ
++ / -- — движение
+ / - — только random access
end ≈ nullptr
реаллокация = смерть итераторов
```

Если хочешь, следующим шагом можно сделать **таблицу категорий итераторов** (`Input`, `Forward`, `Bidirectional`, `RandomAccess`) — это логичное продолжение.