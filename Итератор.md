Формальное определение
[[algorithm]]
=============================
кратко:
vec.begin()- первый 
vec.end() - последний +1    - он же пустой
++ -- + - - все работает
 student_iter->GetAvgScore() 
=============================


**для итераторов эквивалент `nullptr` — это `container.end()`.**



Итератор в C++ — это объект типа, удовлетворяющего требованиям концепции Iterator, который инкапсулирует:

Позицию внутри последовательности или контейнера

Операции для навигации и доступа к элементам

Семантику, определяемую категорией итератора

Из стандарта C++ (ISO/IEC 14882:2020, [iterator.iterators]):

"Iterators are a generalization of pointers that allow a C++ program to work with different

data structures (containers) in a uniform manner."

Итераторы используются при работе с контейнерами, в том числе и с векторами.

Самый простой способ получить итератор — вызвать метод begin().

Для примера возьмём вектор с именами:

std::vector<std::string> client_names = {"Bill", "Jeff", "Mark"};

// Записываем итератор в переменную iter:

/*какой-то возвращаемый тип*/ iter = client_names.begin();

^

std::vector<std::string>::iterator ~~~ auto

---------------------------------------------------------------------------------------

Чтобы прочитать, что содержится в элементе, на который указывает итератор,

используется унарная операция *:

```
// Записать прочитанный элемент в переменную.

std::string first_client_name = *some_iter;

// Переменной first_client_name будет присвоено значение "Bill".

// Вывести в cout.

std::cout << *some_iter << std::endl;

// Вывод: Bill.

// Передать в функцию.

PayRoyalty(*some_iter); <<<---- Это опирации разименовывания.
```

----------------------------------------------------------------------------------------------------------------

Ещё операция * подойдёт, если нужно изменить значение элемента вектора:

*some_iter = "Elon"; <присвоили в вектор по итератору

v

// Изменили первый элемент. Теперь в векторе "Elon", "Jeff", "Mark".

---------------------------------------------------------------------------------------------------------------

Если вектор хранит не простые значения, а объекты класса или структуры, то можно обратиться к методу таким образом:

std::vector<Student> students = ...;

std::vector<Point> points = ...;

auto student_iter = students.begin();

auto points_iter = points.begin();

// Если в классе Student есть метод GetAvgScore():

std::cout << (*student_iter).GetAvgScore() << std::endl;

// Вывести поле "x" из структуры Point:

std::cout << (*points_iter).x << std::endl;

|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

std::cout << student_iter->GetAvgScore() << std::endl;

std::cout << points_iter->x << std::endl;

------------------------------------------------------------------------------------------------------------------------

Удалить элемент по итератору

Также итератор позволяет удалить элемент вектора, если его передать в метод erase():

client_namesС<<-------------------!!!!!!!!!!!!!!!

// Теперь в векторе только "Jeff" и "Mark".

-------------------------------------------------------------------------------------------------------------------------

Влево, вправо и за рамки

Итераторы были бы не очень полезны, если бы их нельзя было двигать. Основные операции перемещения итераторов — ++ и --:

==========

std::vector<int> v = {10, 20, 30, 40};

// 1. Обычный итератор на последний элемент

auto last_elem_it = v.end() - 1;

std::cout << *last_elem_it << std::endl; // 40 - можно разыменовывать

// 2. Делаем шаг вправо - получаем end()

auto past_end_it = last_elem_it + 1; // или ++last_elem_it

// std::cout << *past_end_it << std::endl; // ОШИБКА! Нельзя разыменовывать

// 3. Но это корректный итератор!

std::cout << (past_end_it == v.end()) << std::endl; // true (1)

===========

Итератор, указывающий на фиктивный элемент, — важный атрибут многих алгоритмов.

Чтобы его получить, даже не надо много раз вызывать операцию ++.

Есть специальный метод — end(), антагонист begin().

В отличие от begin(), метод end() возвращает итератор, не указывающий на корректный элемент контейнера.

Этот итератор нельзя двигать вправо, но можно подвинуть влево.

----------------------------------------------------------------

begin() даже у пустого В этом случае begin() равен end().

В этом случае begin() равен end().

------------------------------------------

к итератору применяется прибавление и вычитание чисел:

std::vector<std::string> numbers = {"one", "two", "three", "four",

"five", "six", "seven"};

auto iter = numbers.begin(); // iter => one.

iter += 3;

// iter => four. Сдвинули на 3 вправо.

auto iter2 = iter - 2;

// iter2 => two. Сдвинули на 2 влево и записали в новую переменную.

iter -= -3;

// iter => seven. Сдвиг на -3 влево = сдвиг на 3 вправо.

iter2 += -1;

// iter2 => one. Сдвиг на -1 вправо = сдвиг на 1 влево.

-----------------------------------------------------------

алгоритмы std:advance, std::next и std::prev для перемещения итератора:

// Сместим указатель на два вправо.

// Для вектора это то же, что и iter += 2, но

// алгоритм advance работает с любыми итераторами.

std::advance(iter, 2);

auto iter2 = std::next(iter); // iter2 = iter + 1;

auto iter3 = std::prev(iter); // iter3 = iter - 1;

--------------------------------------------------------------

Помимо перемещения итератора, операция сложения также используется, чтобы получить элемент вектора по номеру. Достаточно прибавить нужный номер к begin(). Сложение итератора и числа можно использовать, если вам требуется получить итератор на элемент по его порядковому номеру.

std::vector<std::string> numbers = {"one", "two", "three", "four",

"five", "six", "seven"};

auto iter1 = numbers.begin() + 0;

// Итератор на нулевой элемент — one.

auto iter5 = numbers.begin() + 4;

// Итератор на четвёртый элемент — five.

int number;

std::cin >> number;

if (number >= 0 && number < numbers.size()) {

auto some_iter = numbers.begin() + number;

}

-----------------------------------------------------

Заметьте, что мы вычитаем итераторы, а получаем число типа int:

auto iter = numbers.begin() + 1;

auto iter2 = numbers.begin() + 3;

int distance_p = iter2 - iter;

// Результат: 2.

------------------------------------

Может получиться и отрицательный результат — если вычитать из итератора, который находится ближе к началу контейнера:

int distance_n = iter - iter2;

// Результат: -2.

Тот же результат можно получить алгоритмом distance:

std::vector<std::string> numbers = {"one", "two", "three", "four",

"five", "six", "seven"};

~~~~

int dist1 = std::distance(numbers.begin(), numbers.end()); // 7.

int dist2 = std::distance(numbers.end(), numbers.begin()); // -7.


--------------------
Второй вид — константные итераторы, которые имеют тип `std::vector<T>::const_iterator`. Такие итераторы не позволяют менять элементы контейнера:

// Обычный итератор превращается в константный:
std::vector<T>::const_iterator iter = client_names.begin();

// Нельзя менять значение, на которое указывает const_iterator.
*iter = "Elon"; // Ошибка!

/**/ Буква "c" в cbegin и cend позволяет получить константный итератор.**--------!!!!!!!!!!!!!!!!
auto iter2 = client_names.cbegin();
auto iter3 = client_names.cend();

Если у вас есть константный вектор, вы не можете менять его элементы. Значит, и итераторы можно получить только константные:

--------------------------------------------------------------------

**Другой вид итераторов — **реверсивные итераторы**. Они позволяют проходить контейнер в обратном порядке. Их возвращают методы `rbegin`, `rend`. При этом `rbegin` указывает на последний элемент контейнера, `rend` — на фиктивный перед первым элементом контейнера. `++` будет двигать итератор в направлении от последнего элемента к первому:

```
std::vector<std::string> names = {"Bill", "Jeff", "Mark"};

// Тут вместо begin и end — rbegin и rend. В остальном мы
// ничего не изменили.
for (auto iter = names.rbegin(); iter != names.rend(); ++iter) {
    std::cout << *iter << std::endl; 
    // Вывод:
    //   Mark
    //   Jeff
    //   Bill
} 
```**
--------------------------------------------------------------------------
Если рассматривать пару итераторов как диапазон, то `v.begin(), v.end()` — это диапазон из всех элементов вектора `v`, а `v.rbegin(), v.rend()` — тот же диапазон, но в обратном порядке.

std::vector<std::string> names = {"Bill", "Jeff", "Mark"};
for (const auto& value : names) {
    std::cout << value << std::endl; 
    // Вывод:
    //   Mark
    //   Jeff
    //   Bill
}

Несмотря на то что этот цикл оперирует довольно сложными объектами — итераторами, его эффективность такая же, как и у обычного цикла `for`, использующего индексы.

------------------------------------------------
Вставка перед нужным элементом позволяет вставить элемент в любое место, в том числе в конец вектора. Для этого нужно взять итератор, указывающий на фиктивный элемент.

std::vector<std::string> names = {"Bill", "Jeff", "Mark"};

auto iter = ++names.begin(); // Jeff.

// Вставили Илона перед Джеффом.
names.insert(iter, "Elon"); // Bill, Elon, Jeff, Mark.

Можно использовать возвращаемое значение. Это будет итератор, указывающий на новый элемент вектора.

std::remove_if
------------------------------------------------------

Методы, которые инвалидируют итераторы:

- `insert`,
- `erase`,
- `push_back`,
- `pop_back`,
- `clear`,
- `reserve` (запомните этот метод — его рассмотрим позже),
- `resize`.

Не инвалидируют:

- все константные методы (`size()`, `empty()`);
- методы получения итераторов (`begin()`, `end()`, `cbegin()`, `cend()`, `rbegin()`, `rend()`, `crbegin()`, `crend()`);
- чтение и изменение элементов через итератор, `[]`, метод `at`.

Если произошла операция, инвалидирующая вектор, то все итераторы этого вектора, полученные до этой операции, становятся некорректными. Необходимо заново проинициализировать итератор.

Реаллокация — это **перевыделение памяти контейнером**, когда старого буфера больше не хватает.

Разберём без воды.

## Что именно происходит

Для контейнеров с непрерывной памятью (`std::vector`, `std::string`):

1. Контейнер хранит элементы в одном куске памяти.
    
2. Этот кусок имеет:
    
    - `size()` — сколько элементов реально есть
        
    - `capacity()` — сколько **можно** хранить без перевыделения
        
3. Когда операция (например `push_back`, `insert`) требует места больше, чем `capacity()`:
    
    - выделяется **новый, больший** кусок памяти
        
    - все элементы **копируются/перемещаются** туда
        
    - старый кусок освобождается
      
    ## 2. Настоящее правило (одно, запомни его)
----------------------------------------
### Итератор инвалидируется, если:

1. **элемент, на который он указывает, был удалён**,  
    или
    
2. **произошла реаллокация памяти** (перенос вектора).