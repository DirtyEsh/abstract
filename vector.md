
[[Итератор]]
// Подключаем библиотеку:
#include <vector>

```


std::cout << "number size: " << sizeof(number) << std::endl // 8.
std::vector<double> vec;
vec.push_back(1.0);
vec.push_back(2.0);
vec.push_back(3.0);

std::cout << sizeof(vec) << std::endl;           // 24 байта (объект вектора)
std::cout << vec.size() * sizeof(double) << std::endl;  // 24 байта (данные)
// Но vec.capacity() может быть больше!

```
---
Вернёмся к методу `resize()`. Он позволяет изменять размер вектора в меньшую и бóльшую сторону. При уменьшении размера инвалидируются итераторы, начиная с отсечённого элемента. При увеличении важную роль играет вместимость: если её достаточно, то размер изменится без реаллокации, а если нет — произойдёт реаллокация и инвалидация всех итераторов. Причём новая вместимость вектора необязательно будет совпадать с новым размером.

std::vector<int> nums{1, 2, 3}; nums.reserve(7); // Резервируем свободное место. PrintVectorInfo(nums);


---
объект вектор - сам по себе хранитт только инфу - начальник склада - данные в *Куче* хроняться , поэтому по факту занимают больше места 
Вставка элементов в конец вектора тоже может быть долгой, если закончилось место. Но это происходит достаточно редко. - в случае когда место закончилось, заполняется 
std::cout << "capacity – " << v.capacity() << std::endl;

Вектор может использовать [[Итератор]]
# Создание
## // Создаём пустой вектор чисел:
std::vector<int> numbers{};
## // Создаёт вектор из десяти элементов со значением по умолчанию.
// Для целочисленного типа это 0.
std::vector<int> numbers(10);
##// Создаёт вектор из десяти элементов со значением 
 // "Тик-так" во всех элементах.
std::vector<std::string> numbers(10, "Тик-так");

## //через временный вектор 
std::vector<int> numbers = {1, 2, 3, 4, 5, 4, 3, 2, 1};

## // Или
std::vector<int> another_numbers({10, 11, 12});

## Если компилятор может вывести тип элементов, то указывать его не обязательно:

## // Компилятор сам поймёт, что vector<int>.
std::vector numbers = {1, 2, 3, 4, 5, 4, 3, 2, 1};

## // Надо быть осторожным, это будет vector<const char*>:
std::vector sharikov = {"Аб", "Абыр", "Абырвалг"}; // Не string! 

## std::vector<int> numbers = {1, 2, 3, 4, 5, 4, 3, 2, 1};
std::vector another_numbers = numbers;

# Методы вектора 
##Добавление  
// Создаёт пустой вектор.
 std::vector<std::string> queue{};

 // И добавим 4 элемента:
 queue.push_back("Первый покупатель");
 queue.push_back("Второй покупатель");
 queue.push_back("Третий покупатель");
 queue.push_back("Четвёртый покупатель");
 
 Удалить последний элемент
 queue.pop_back(); 
 
 Проверка на пустоту
 .empty()
 if(!queue.empty()) {
    std::cout << "Вектор не пустой. Можно вызвать pop_back()." << std::endl;
}

Размер: .size() - вернет индекс последнего +1
Отчистить:      .clear();

 Вернуть элемент
 std::vector`: `[]` vs `at()` — выжимка
- `v[i]` — **без проверки**, выход за границы → **UB**, быстрее, `noexcept`
- `v.at(i)` — **с проверкой**, выход → `std::out_of_range`, медленнее
cpp
v[i];      // UB если i некорректен
v.at(i);   // exception если i некорректен

Правило:** внешний индекс → `at()`, внутренний → `[]`

Первый и последний элемент:
// Создание вектора.
std::vector<std::string> fruits{"яблоко", "ананас", "груша", "апельсин"};

// Вывод элемента с индексом 1:
std::cout << "fruits[1]: "  << fruits[1] << std::endl;
						|
// Вывод первого фрукта из списка:
std::cout << "Первый фрукт: " << fruits.front() << std::endl;
								|
// Последний из списка:
std::cout << "Последний фрукт " << fruits.back() << std::endl;
								|
std::vector::pop_back()` — выжимка

- Удаляет **последний элемент
- Не возвращает значение
- Не делает проверок
- `noexcept` (если деструктор не бросает)
  
  ---------------
  # `resize()` в `std::vector`

## Кратко
Изменяет размер вектора. Если новый размер больше — добавляет элементы, если меньше — удаляет лишние.

## Синтаксис
```cpp
void resize(size_t new_size);
void resize(size_t new_size, const T& value);
```

## Примеры
```cpp
std::vector<int> vec = {1, 2, 3};

vec.resize(5);          // {1, 2, 3, 0, 0} - добавляет нули
vec.resize(5, 42);      // {1, 2, 3, 42, 42} - добавляет 42
vec.resize(2);          // {1, 2} - удаляет последний элемент
vec.resize(0);          // {} - очищает вектор
```

## Особенности
- Увеличивает `size()`, может увеличить `capacity()`
- При уменьшении деструкторы вызываются сразу
- При увеличении без значения используется **value-initialization** (`0` для int, `""` для string и т.д.)
- Сложность: O(|new_size - current_size|)

## `resize()` vs `reserve()`
- `resize(n)` - меняет `size()` на n элементов   "перезаписать размер"
- `reserve(n)` - готовит место, но `size()` не меняет    "зарезервировать"
  
```
  std::vector<int> vec = {1, 2, 3};

// reserve - только увеличивает capacity если нужно
vec.reserve(10);  // size=3, capacity>=10, элементы {1,2,3} остаются

// resize - добавляет элементы
vec.resize(10);   // size=10, capacity>=10, элементы {1,2,3,0,0,0,0,0,0,0}

std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

// resize УДАЛИТ лишние элементы "перезаписать размер"
vec.resize(5);    // теперь {1, 2, 3, 4, 5}, size=5

// reserve НЕ УМЕНЬШАЕТ размер "зарезервировать"
vec.reserve(5);   // НИЧЕГО НЕ ДЕЛАЕТ! capacity останется прежним
                  // потому что уже выделено больше памяти
                  
// ДОБАВЛЯЕТЕ много элементов? → reserve
// НУЖНО конкретное количество сейчас? → resize
// ХОТИТЕ уменьшить память? → shrink_to_fit или swap трюк  <------------
// НИКОГДА не используйте reserve для уменьшения!
```
Выделение новой памяти и частые «переезды» неэффективны. Если вы заранее знаете, сколько элементов будет в векторе, используйте `reserve`. Этот метод изменит вместимость так, чтобы она была не меньше нужного размера:

```
std::vector<int> nums{1, 2, 3};
nums.reserve(7); // Резервируем свободное место.
PrintVectorInfo(nums);
// size – 3.
// capacity – 7.
// data – 0xb1bfe0.
nums.push_back(4);
nums.push_back(5);
nums.push_back(6);
nums.push_back(7);
PrintVectorInfo(nums);
// size – 7.
// capacity – 7.
// data – 0xb1bfe0. 
```

Вызов `reserve` позволил избежать реаллокаций и эффективно вставить элементы. Его часто используют, если нужно, например, построить вектор на основе другого вектора:



---

```
std::vector<int> vec;
vec.reserve(1000);
for(int i = 0; i < 10; i++) vec.push_back(i);
// size=10, capacity=1000 - много лишней памяти!

// ОШИБКА: reserve не уменьшает
vec.reserve(10);  // НИЧЕГО НЕ ДЕЛАЕТ! capacity останется 1000

// ПРАВИЛЬНО:
vec.shrink_to_fit();  // Попросить освободить лишнюю память
// ИЛИ
std::vector<int>(vec).swap(vec);  // Старый трюк

```
---
std::vector<std::string> GetStudentNames(const std::vector<Student>& students) {
    std::vector<std::string> result;
    // Знаем, что в векторе result будет столько же элементов,
    // сколько и в students. Зарезервируем под них место.
    result.reserve(students.size());
    
    // Теперь вставим без реаллокаций.
    for (const auto& s : students) {
        result.push_back(s.name);
    }
    
    return result;
} 
```
```