
[[Итератор]]
// Подключаем библиотеку:
#include <vector>
Вектор может использовать [[Итератор]]
# Создание
## // Создаём пустой вектор чисел:
std::vector<int> numbers{};
## // Создаёт вектор из десяти элементов со значением по умолчанию.
// Для целочисленного типа это 0.
std::vector<int> numbers(10);
##// Создаёт вектор из десяти элементов со значением 
 // "Тик-так" во всех элементах.
std::vector<std::string> numbers(10, "Тик-так");

## //через временный вектор 
std::vector<int> numbers = {1, 2, 3, 4, 5, 4, 3, 2, 1};

## // Или
std::vector<int> another_numbers({10, 11, 12});

## Если компилятор может вывести тип элементов, то указывать его не обязательно:

## // Компилятор сам поймёт, что vector<int>.
std::vector numbers = {1, 2, 3, 4, 5, 4, 3, 2, 1};

## // Надо быть осторожным, это будет vector<const char*>:
std::vector sharikov = {"Аб", "Абыр", "Абырвалг"}; // Не string! 

## std::vector<int> numbers = {1, 2, 3, 4, 5, 4, 3, 2, 1};
std::vector another_numbers = numbers;

# Методы вектора 
##Добавление  
// Создаёт пустой вектор.
 std::vector<std::string> queue{};

 // И добавим 4 элемента:
 queue.push_back("Первый покупатель");
 queue.push_back("Второй покупатель");
 queue.push_back("Третий покупатель");
 queue.push_back("Четвёртый покупатель");
 
 Удалить последний элемент
 queue.pop_back(); 
 
 Проверка на пустоту
 .empty()
 if(!queue.empty()) {
    std::cout << "Вектор не пустой. Можно вызвать pop_back()." << std::endl;
}

Размер: .size() - вернет индекс последнего +1
Отчистить:      .clear();

 Вернуть элемент
 std::vector`: `[]` vs `at()` — выжимка
- `v[i]` — **без проверки**, выход за границы → **UB**, быстрее, `noexcept`
- `v.at(i)` — **с проверкой**, выход → `std::out_of_range`, медленнее
cpp
v[i];      // UB если i некорректен
v.at(i);   // exception если i некорректен

Правило:** внешний индекс → `at()`, внутренний → `[]`

Первый и последний элемент:
// Создание вектора.
std::vector<std::string> fruits{"яблоко", "ананас", "груша", "апельсин"};

// Вывод элемента с индексом 1:
std::cout << "fruits[1]: "  << fruits[1] << std::endl;
						|
// Вывод первого фрукта из списка:
std::cout << "Первый фрукт: " << fruits.front() << std::endl;
								|
// Последний из списка:
std::cout << "Последний фрукт " << fruits.back() << std::endl;
								|
std::vector::pop_back()` — выжимка

- Удаляет **последний элемент
- Не возвращает значение
- Не делает проверок
- `noexcept` (если деструктор не бросает)
  
  ---------------
  # `resize()` в `std::vector`

## Кратко
Изменяет размер вектора. Если новый размер больше — добавляет элементы, если меньше — удаляет лишние.

## Синтаксис
```cpp
void resize(size_t new_size);
void resize(size_t new_size, const T& value);
```

## Примеры
```cpp
std::vector<int> vec = {1, 2, 3};

vec.resize(5);          // {1, 2, 3, 0, 0} - добавляет нули
vec.resize(5, 42);      // {1, 2, 3, 42, 42} - добавляет 42
vec.resize(2);          // {1, 2} - удаляет последний элемент
vec.resize(0);          // {} - очищает вектор
```

## Особенности
- Увеличивает `size()`, может увеличить `capacity()`
- При уменьшении деструкторы вызываются сразу
- При увеличении без значения используется **value-initialization** (`0` для int, `""` для string и т.д.)
- Сложность: O(|new_size - current_size|)

## `resize()` vs `reserve()`
- `resize(n)` - меняет `size()` на n элементов
- `reserve(n)` - готовит место, но `size()` не меняет