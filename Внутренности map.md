```
std::map<std::string, int> prices = {
    {"Milk"s, 99},
    {"Donut"s, 150},
};

// Пытаемся изменить значение элемента, которого ещё нет.
prices["Croissant"s] += 10; 

// Вывод:
// Croissant, 10
// Donut, 150
// Milk, 99 
```

При обращении по ключу «Croissant» в словаре появляется новый элемент с таким ключом и значением 0, которое сразу же увеличивается на 10.

В следующей таблице приведены результаты выполнения операции `[]` для различных вариаций вектора и словаря.


|                                  | есть ключ                       | нет ключа     |
| -------------------------------- | ------------------------------- | ------------- |
| vector                           | ок                              | непредсказуем |
| const<br>vector                  | ок                              | непредсказуем |
| map                              | ок                              | вернет        |
| const map<br>(ошибка компиляции) | НЕ допускает<br>нужны итераторы | не допускает  |
### Элементы словаря и итераторы

Каждый элемент в `std::map` представляет собой пару из ключа и значения: `std::pair<const Key, Value>`. Как и для любой пары, для них работает обращение через `first` и `second`, которое вы уже встречали в некоторых примерах.

```c
auto iterator = prices.find("Milk"s); 

// Сохраним элемент целиком в тип pair. 
std::pair<std::string, int> item = *iterator;
std::cout << item.first << ": "s << item.second << std::endl; 
```

Вы могли обратить внимание, что при добавлении элементов в словарь с помощью `insert` ключ и значение заключаются в скобки `{}`. Это нужно, поскольку параметр должен быть типа `pair`.

```c
// Можно создать пару с помощью {}.
prices.insert({"Salt"s, 40});

// Или использовать переменную.
std::pair<std::string, int> new_item = {"Sugar"s, 80};
prices.insert(new_item); 
```
Итераторы в `std::map` и в векторе работают аналогично: они определяют позицию элемента (в данном случае — пары), по которой к нему можно обратиться. Итератор `begin` указывает на первый элемент словаря, а `end` — на позицию **за** словарём.

```
std::map<std::string, int> prices = {
    {"Milk"s, 99},
    {"Donut"s, 150},
};

// Выведет значение "Donut".
std::cout << prices.begin()->first << std::endl;

// Ошибка: на позиции end элементов уже нет.
std::cout << prices.end()->first << std::endl; 
```
---
**итераторы словаря не поддерживают операции прибавления и вычитания чисел. Зато доступны `--` и `++`:**
---
```
// Переход к следующему элементу с помощью инкремента разрешён.
std::cout << (++accounts.begin())->first << std::endl;

// Переход на указанное количество позиций вызовет ошибку.
std::cout << (accounts.begin() + 3)->first << std::endl; // <- Ошибка!
```


Для перемещения на определённое количество позиций можно использовать функцию `std::advance`, которая передвигает итератор на заданное количество шагов:

```
auto it = numbers.begin(); 
std::advance(it, 3); // Перемещаем итератор на 3 позиции вперёд.
```

Похожим образом работают функции `std::next` и `std::prev`. Они не меняют итератор, но позволяют получить новый, смещённый:

```
auto other_it = std::prev(it, 2); // other_it -> {2, "two"}.

auto iter_to_last = std::next(other_it, 3); // iter_to_last -> {5, "five"}. 
```

Вычитание итераторов друг из друга также недоступно. Чтобы определить количество шагов между двумя итераторами, можно использовать функцию `std::distance`.

```
auto iter_begin = numbers.begin();
auto iter_end = numbers.find("4"s);

// Расстояние между первым элементом и элементом "4" равно 3.
int dist = std::distance(iter_begin, iter_end); 
```

Все элементы в такой структуре данных упорядочены по ключу, и при изменении одного из них этот порядок будет нарушен. Поэтому, чтобы заменить ключ, необходимо сначала удалить элемент из словаря, а затем вставить новый.


---
### Удаление элементов

Для удаления элемента используется метод `erase`. Он возвращает логическое значение `true`, если указанный ключ найден и элемент удалён, и `false` в противном случае.

```
auto is_erased = prices.erase("Milk"s);

// Если ключ найден, вставляем новый элемент на место старого.
if (is_erased) { 
    prices.insert({"Сhocolate milk"s, 220});
} else {
    std::cout << "Ключ не найден"s;
}
    
// Donut: 150
// Сhocolate milk: 220 
```
 ### удаление диапазона
 
`erase` позволяет сделать это с помощью двух итераторов, указывающих на границы диапазона. При этом элемент, соответствующий верхней границе, не входит в диапазон и не удаляется.

Ниже приведён пример с удалением из словаря элементов от `{"Donut"s, 150}` до `{"Milk chocolate"s, 150}` включительно.

```
std::map<std::string, int> prices = {
    {"Donut"s, 150},
    {"Milk"s, 100},
    {"Milk chocolate"s, 150},
    {"Sugar"s, 80},
}; 

// Находим границы диапазона.
auto it_begin = prices.find("Donut"s);
auto it_end = ++prices.find("Milk chocolate"s);

if ((it_begin != prices.end()) && (it_end != prices.end())) {
    prices.erase(it_begin, it_end);
}

// Результат после удаления:
// Sugar, 80 
```

Обратите внимание: чтобы элемент `{"Milk chocolate"s, 150}` попал в удаляемый диапазон, его итератор нужно сдвинуть на следующую позицию, увеличив на 1.

### Инвагинация итератора
Как вы знаете, итераторы вектора довольно чувствительны: при изменении количества элементов они могут инвалидироваться.

Итераторы `std::map` гораздо более устойчивые. Причина в том, что элементы словаря хранятся не подряд, а разрозненно. Благодаря этому им никогда не нужно переезжать, делая реaллокацию.

Итератор на элемент `std::map` остаётся корректным, если вы:

- Добавляете новый элемент.
- Удаляете другой элемент.
- Меняете значение любого элемента, в том числе того, на который указывает итератор.

Единственный случай, когда итератор действительно будет инвалидироваться, — удаление элемента, на который он указывает

---
- `std::map<Key, std::vector<int>>` ✅ можно `begin() + 1`
    
- `std::map<Key, std::deque<int>>` ✅ можно `begin() + 1`
    
- `std::map<Key, std::list<int>>` ❌ нельзя (`list` не поддерживает `+`)
    
- `std::map<Key, std::set<int>>` ❌ нельзя (у итератора `set` нет `+`)
    
- `std::map<Key, std::map<...>>` ❌ нельзя (итераторы `map` — не random access)
    

Если контейнер не random access, делай так:

`auto it = std::next(it_math->second.begin());`

---
### Словарь со сложными типами данных

Контейнер `std::map` — шаблон, а потому может хранить не только встроенные типы (вроде чисел и строк), но и более сложные объекты. Например, можно создать словарь с векторами.
Или даже другие словари.
Или даже другие словари. или объекты класса

### Компараторы для словарей

Сортировка ключей в словаре происходит с помощью операций сравнения, которые определяют порядок элементов. Для встроенных типов используется стандартное сравнение — именно поэтому числовые или строковые ключи сортируются по возрастанию.

Контейнер `std::map` позволяет задавать собственные правила для упорядочивания элементов. Благодаря этому можно не только иначе сортировать стандартные типы, но и использовать в качестве ключей более сложные объекты.

Правила сортировки задаются через компаратор — функцию, которая принимает два параметра и возвращает логический результат их сравнения. В `std::map` компаратор указывается в момент создания словаря и не может быть изменён в процессе работы.

Существует несколько способов задать компаратор. Его можно объявить в виде функционального объекта (структуры или класса) и передавать как шаблонный аргумент.

Создадим компаратор, сортирующий ключи в обратном порядке.

```c
// Компаратор для сортировки строк по убыванию.
struct Comparator{
    bool operator()(std::string a, std::string b) const {
        return a > b;
    }
};

// Передаём Comparator в виде шаблонного аргумента.
std::map<std::string, int, Comparator> prices = {
    {"Milk"s, 99},
    {"Sugar"s, 110},
    {"Donut"s, 150},
};

// Теперь ключи хранятся в обратном порядке.   
// Sugar: 110
// Milk: 99
// Donut: 150 
```

Чтобы сократить запись, можно объявить компаратор в виде лямбда-функции.

```
auto comparator = [](std::string a, std::string b) {
    return a > b;
};

std::map<std::string, int, decltype(comparator)> prices = {
    {"Milk"s, 99},
    {"Sugar"s, 110},
    {"Donut"s, 150},
}; 
```

В этом случае он также указывается среди шаблонных аргументов. Поскольку используется анонимная лямбда-функция, для определения типа необходимо использовать [[`decltype`]].