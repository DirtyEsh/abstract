Есть несколько способов добавить элементы в `QList`. Первый из них — использовать знакомые по вектору методы `push_back` и `insert`. Наличие первого позволяет использовать `back_inserter` с `QList`.

В качестве примера возьмём `QList` с числами и добавим элементы, используя знакомые методы:

```
QList<int> list;
// Как в вектор:
list.push_back(2);
list.insert(0, 3); 
```

В Qt есть свой метод для добавления элементов в конец — `append`. Он используется не только для `QList`, но ещё и для других Qt-контейнеров, таких как `QVector` и `QStringList`. `QStringList` — это частный случай `QList` с уже определённым типом элементов `QString`.


Начиная с версии Qt 6 `QList` и `QVector` — это одно и то же.

Метод `append` удобно использовать для добавления как одного элемента, так и сразу нескольких:

```
QList<int> list{};
// Одно значение:
list.append(1);
// Несколько значений:
list.append({2, 3, 4});
// list: 1, 2, 3, 4. 
```

Ещё один способ заполнения листа — использование операции `<<`. Как и `append`, операция позволяет добавить одну или сразу несколько записей друг за другом:

```
QList<QString> friends_list{};
friends_list << "Маша" << "Вера" << "Илья" << "Пётр";
// friends_list: "Маша", "Вера", "Илья", "Пётр". 
```

Читать элементы из контейнера `QList` можно, как и из вектора, используя квадратные скобки или метод `at`. Частные случаи — методы `back()`и `front()`. Они позволяют получить последний и первый элементы из списка.

Функции `find` и `find_if` поддерживают поиск в `QList` по итераторам, аналогично `std::vector`.

```
// Создаём список целых чисел.
QList<int> list{1, 2, 3, 4, 5};

// Поиск значения 3.
QList<int>::iterator it = std::find(list.begin(), list.end(), 3);

if (it != list.end()) {
    std::cout << "Найдено значение: " << *it << "." << std::endl;
} else {
    std::cout << "Значение не найдено." << std::endl;
}

// Результат: Найдено значение: 3. 
```

Неудобство при работе с `std::find` — это возврат итератора. При необходимости узнать позицию элемента в списке нужно будет дополнительно подключить `std::distance`:

```
auto it = std::find(list.begin(), list.end(), 3);
int index = -1;
if(it != list.end()) {
    index = std::distance(list.begin(), it);
} 
```

узнать позицию элемента в списке нужно будет дополнительно подключить `std::distance`:

```
auto it = std::find(list.begin(), list.end(), 3);
int index = -1;
if(it != list.end()) {
    index = std::distance(list.begin(), it);
} 
```