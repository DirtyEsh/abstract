Есть несколько способов добавить элементы в `QList`. Первый из них — использовать знакомые по вектору методы `push_back` и `insert`. Наличие первого позволяет использовать `back_inserter` с `QList`.

В качестве примера возьмём `QList` с числами и добавим элементы, используя знакомые методы:

```
QList<int> list;
// Как в вектор:
list.push_back(2);
list.insert(0, 3); 
```

В Qt есть свой метод для добавления элементов в конец — `append`. Он используется не только для `QList`, но ещё и для других Qt-контейнеров, таких как `QVector` и `QStringList`. `QStringList` — это частный случай `QList` с уже определённым типом элементов `QString`.


Начиная с версии Qt 6 `QList` и `QVector` — это одно и то же.

Метод `append` удобно использовать для добавления как одного элемента, так и сразу нескольких:

```
QList<int> list{};
// Одно значение:
list.append(1);
// Несколько значений:
list.append({2, 3, 4});
// list: 1, 2, 3, 4. 
```

Ещё один способ заполнения листа — использование операции `<<`. Как и `append`, операция позволяет добавить одну или сразу несколько записей друг за другом:

```
QList<QString> friends_list{};
friends_list << "Маша" << "Вера" << "Илья" << "Пётр";
// friends_list: "Маша", "Вера", "Илья", "Пётр". 
```

Читать элементы из контейнера `QList` можно, как и из вектора, используя квадратные скобки или метод `at`. Частные случаи — методы `back()`и `front()`. Они позволяют получить последний и первый элементы из списка.

Функции `find` и `find_if` поддерживают поиск в `QList` по итераторам, аналогично `std::vector`.

```
// Создаём список целых чисел.
QList<int> list{1, 2, 3, 4, 5};

// Поиск значения 3.
QList<int>::iterator it = std::find(list.begin(), list.end(), 3);

if (it != list.end()) {
    std::cout << "Найдено значение: " << *it << "." << std::endl;
} else {
    std::cout << "Значение не найдено." << std::endl;
}

// Результат: Найдено значение: 3. 
```

Неудобство при работе с `std::find` — это возврат итератора. При необходимости узнать позицию элемента в списке нужно будет дополнительно подключить `std::distance`:

```
auto it = std::find(list.begin(), list.end(), 3);
int index = -1;
if(it != list.end()) {
    index = std::distance(list.begin(), it);
} 
```

узнать позицию элемента в списке нужно будет дополнительно подключить `std::distance`:

```
auto it = std::find(list.begin(), list.end(), 3);
int index = -1;
if(it != list.end()) {
    index = std::distance(list.begin(), it);
} 
```

`QList` обладает удобным интерфейсом для поиска элементов по их значениям и получения их индексов с помощью методов `indexOf` и `lastIndexOf`. Их использование полезно в ситуациях, когда вам нужно работать с позицией элемента, а не только с его значением. Теперь код можно переписать компактнее:

```
QList<int> list{1, 2, 3, 4, 5};
int index1 = list.indexOf(3);
// Результат: index1 = 2.

int index2 = list.indexOf(42);
// Результат: index2 = -1. 
```

Если в последовательности будет несколько одинаковых значений — `indexOf` вернёт первый найденный элемент. При поиске 42 мы получили результат `-1`. Это значение показывает, что элемент не найден: так же, как `end()` при использовании `std::find`. Поиск начинается с позиции 0. Чтобы указать другую позицию старта, передайте её вторым параметром. Например, укажем поиск числа 2 с позиции 3:

```
QList<int> list{1, 2, 3, 4, 5};
int index_2 = list.indexOf(2, 3);
// Ищем значение 2 с индекса 3, то есть в значениях {4, 5}.
// Результат: index_2 = -1.

int index_4 = list.indexOf(4, 3);
// Результат: index_4 = 3. 
```
ретья позиция — это элемент со значением 4. Поиск выполняется на отрезке с элементами {4, 5}.

Метод с названием `lastIndexOf` схож с `indexOf`, но поиск начинается с конца, поэтому возвращается индекс последнего вхождения в список.

### QList и виджеты Qt

`QList` пригодится при использовании в графических виджетах Qt: как для заполнения, так и для сохранения считанных данных.

К примеру, графический виджет — выпадающий список (`QComboBox`) заполняется элементами с помощью метода `addItems(список)`, где список — это `QStringList` или `QList<QString>`. В примере выше мы заполнили лист именами друзей, теперь при наличии виджета `cb_list_friends` можем добавить в него строки, передав лист со значениями:

```
 ui->cb_list_friends->addItems(list_friends); 
```

Предположим, теперь хотим прочитать всё, что добавили. Применим `QStringList`, чтобы сохранить все элементы выпадающего списка. Для этого надо узнать количество элементов в списке с помощью метода `count()`, затем прочитать значение элемента с помощью `itemText()`, передав в него индекс:

```
QStringList items{};
for(int i = 0; i < ui->cb_list_friends->count(); ++i) {
    items << ui->cb_list_friends->itemText(i);
} 
```

С помощью `indexOf` в `items` можем найти индекс записи и использовать в методе выпадающего списка `setCurrentIndex`, чтобы изменить выбранное значение в нём:

```
int index = items.indexOf("Маша");
ui->cb_list_friends->setCurrentIndex(index); 
```

В этом уроке вы познакомились с двумя новыми контейнерами — `QMap` и `QList`. Помимо схожих методов с аналогичными контейнерами стандартной библиотеки, они обладают собственными. Это делает разработку программ во фреймворке Qt с ними удобной.