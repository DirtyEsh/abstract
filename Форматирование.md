## Форматирование вывода в C++ — коротко и по делу

---
[[Qt форматирование]]
------------------------------------------------
## 1. Классика: `iostream`

Просто, многословно, типобезопасно, **медленно**.

```cpp
int x = 5;
double y = 3.14;

std::cout << "x=" << x << ", y=" << y << '\n';
```

### Манипуляторы

```cpp
#include <iomanip>

std::cout << std::setw(6) << x;        // ширина
std::cout << std::setprecision(3) << y;
std::cout << std::fixed << y;          // фиксированная точка
std::cout << std::hex << 255;           // ff
```

Минус: состояние потока липкое.

---

## 2. `printf` (C-style)

Быстро, компактно, **не типобезопасно**.

```cpp
printf("x=%d y=%.2f\n", x, y);
```

Плюс: скорость  
Минус: UB при несовпадении форматов

---

## 3. `std::format` (C++20, рекомендуемый)

Типобезопасно, читабельно, без состояния.

```cpp
#include <format>

std::string s = std::format("x={} y={:.2f}", x, y);
std::cout << s;
```

### Форматы

```cpp
std::format("{:6}", x);      // ширина
std::format("{:.3f}", y);    // точность
std::format("{:#x}", 255);   // 0xff
```

Факт: аналог Python `format`.

---

## 4. В поток напрямую (C++23)

```cpp
#include <print>

std::print("x={} y={}\n", x, y);
```

Самый чистый вариант, если доступен.

---

## 5. Форматирование через `ostringstream`

Когда нужен строковый буфер.

```cpp
#include <sstream>

std::ostringstream os;
os << x << " " << y;
auto s = os.str();
```

Использовать редко.

---

## 6. Перегрузка `operator<<`

Для своих типов.

```cpp
struct Point {
    int x, y;
};

std::ostream& operator<<(std::ostream& os, const Point& p) {
    return os << "(" << p.x << ", " << p.y << ")";
}
```

---

## 7. Перегрузка `std::formatter` (C++20)

Современно и мощно.

```cpp
template<>
struct std::formatter<Point> : std::formatter<int> {
    auto format(const Point& p, auto& ctx) {
        return std::format_to(ctx.out(),
            "({}, {})", p.x, p.y);
    }
};
```

Теперь:

```cpp
std::format("p={}", point);
```

---

## Сравнение (коротко)

|Способ|Типобезопасность|Скорость|Рекомендация|
|---|---|---|---|
|`cout`|да|низкая|простые задачи|
|`printf`|нет|высокая|legacy|
|`std::format`|да|высокая|основной|
|`std::print`|да|высокая|идеал|
|`ostringstream`|да|низкая|буферы|
|`operator<<`|да|средняя|свои типы|

---

## Жёсткое правило

- **Новый код** → `std::format / std::print`
    
- **Логи / API** → `std::format`
    
- **Учёба / отладка** → `cout`
    
- **Никогда** не мешай `printf` и `cout` без синхронизации
    

Если хочешь — разберём `std::format` полностью (спекификаторы, выравнивание, локали).

--------------------------------------------


еще раз подругому # Конспект: Форматирование строк в C++

## Старый способ (до C++20)
```cpp
#include <iostream>
#include <iomanip>
#include <sstream>

int x = 42;
double d = 3.14159;
std::string name = "Ivan";

// 1. printf (небезопасно, но быстро)
printf("%d %.2f %s\n", x, d, name.c_str());

// 2. std::stringstream (безопасно, но медленно)
std::stringstream ss;
ss << "x=" << x << ", d=" << std::fixed << std::setprecision(2) << d;
std::string s = ss.str();

// 3. std::to_string (ограничено)
s = "Value: " + std::to_string(x); // "Value: 42"
```

## C++17: `std::to_chars` (низкоуровневое, быстрое)
```cpp
#include <charconv>

char buffer[20];
auto [ptr, ec] = std::to_chars(buffer, buffer + 20, 3.14159);
*ptr = '\0'; // "3.14159"

// Только для чисел, нет поддержки строк
// Не выделяет память, не кидает исключения
```

## C++20: `std::format` (основной способ)

### Базовое использование
```cpp
#include <format>

// Простая подстановка
auto s1 = std::format("Hello, {}!", "world"); // "Hello, world!"

// Позиционные аргументы
auto s2 = std::format("{1} {0}", "a", "b"); // "b a"

// Форматирование чисел
auto s3 = std::format("int: {0:d}, hex: {0:#x}, bin: {0:b}", 255);
// "int: 255, hex: 0xff, bin: 11111111"

// Float с точностью
auto s4 = std::format("{:.2f}", 3.14159); // "3.14"
```

### Спецификаторы формата
```cpp
// Общий синтаксис: {[индекс][:спецификатор]}
// индекс - позиция аргумента (0, 1, 2...)
// спецификатор - настройки форматирования

// Выравнивание и ширина
std::format("{:<10}", "left");     // "left      " (влево)
std::format("{:>10}", "right");    // "     right" (вправо)
std::format("{:^10}", "center");   // "  center  " (по центру)
std::format("{:*^10}", "fill");    // "***fill***" (заполнитель)

// Числа
std::format("{:+}", 42);           // "+42" (знак всегда)
std::format("{:06d}", 42);         // "000042" (дополнение нулями)
std::format("{:#x}", 255);         // "0xff" (шестнадцатеричное)
std::format("{:.3f}", 3.14159);    // "3.142" (точность)

// Даты и время (C++20)
#include <chrono>
auto now = std::chrono::system_clock::now();
std::format("{:%Y-%m-%d %H:%M:%S}", now); // "2024-01-15 14:30:00"
```

### `std::format_to` (запись в буфер)
```cpp
#include <format>
#include <vector>

std::vector<char> buf(100);
auto end = std::format_to(buf.begin(), "{} = {}", "x", 42);
// buf содержит "x = 42"
```

### `std::formatted_size` (размер результата)
```cpp
size_t n = std::formatted_size("{} + {} = {}", 2, 2, 4); // n = 11
```

## C++23: `std::print` (вывод напрямую)
```cpp
#include <print> // C++23

std::print("Hello, {}!\n", "world"); // Прямой вывод в stdout
std::println("Value: {}", 42);       // С автоматическим \n

// Вывод в файл
std::print(std::cerr, "Error: {}\n", message);
```

## Пользовательские типы
```cpp
// C++20: специализация formatter
struct Point { int x, y; };

template<>
struct std::formatter<Point> {
    constexpr auto parse(std::format_parse_context& ctx) {
        return ctx.begin(); // парсинг спецификатора
    }
    
    auto format(const Point& p, std::format_context& ctx) const {
        return std::format_to(ctx.out(), "({}, {})", p.x, p.y);
    }
};

Point p{10, 20};
auto s = std::format("Point: {}", p); // "Point: (10, 20)"
```

## Сравнение производительности
1. **`std::format`** - оптимальный баланс скорости и удобства
2. **`std::to_chars`** - максимальная скорость, но сложнее
3. **stringstream** - медленнее, но совместимо со старым кодом
4. **`printf`** - быстро, но небезопасно (нет проверки типов)

## Итог
- **C++17**: `std::to_chars` для низкоуровневого форматирования чисел
- **C++20**: `std::format` как основной безопасный и быстрый способ
- **C++23**: `std::print` для удобного вывода
- **Лучшая практика**: использовать `std::format` для новых проектов

```cpp
// Современный C++ код (C++20+)
#include <format>
#include <iostream>

int main() {
    std::string name = "Alice";
    int age = 30;
    double score = 95.5;
    
    auto message = std::format(
        "{:<10} | {:>3} лет | Оценка: {:.1f}%",
        name, age, score
    );
    
    std::cout << message << std::endl;
    return 0;
}
```