Ниже — **ультимативная таблица**. Это то, что нужно держать в голове, без исключений и лирики.

---

## `{ }`, `[ ]`, `( )`, `;` в C++

|Символ|Где используется|Что означает|Пример|
|---|---|---|---|
|`{ }`|Тело блока|Область видимости, блок кода|`{ int x = 0; }`|
|`{ }`|Инициализация|**list-initialization**|`int x{5};`|
|`{ }`|Класс / struct|Определение типа|`struct A { int x; };`|
|`{ }`|Namespace / enum|Группировка|`namespace n {}`|
|`{ }`|Lambda тело|Код лямбды|`[]{}`|
|`{ }`|`if / for / while`|Тело управляющей конструкции|`if (x) {}`|
|`{ }`|`std::initializer_list`|Безопасная инициализация|`std::vector v{1,2,3};`|

---

|Символ|Где используется|Что означает|Пример|
|---|---|---|---|
|`( )`|Вызов|Вызов функции / callable|`f(1)`|
|`( )`|Условия|Условие|`if (x > 0)`|
|`( )`|Группировка|Приоритет|`(a + b) * c`|
|`( )`|Ctor|Конструктор|`A a(1);`|
|`( )`|Cast (C-style)|Приведение типа|`(int)x` ⚠️|

---

|Символ|Где используется|Что означает|Пример|
|---|---|---|---|
|`[ ]`|Индексация|Доступ по индексу|`v[i]`|
|`[ ]`|Lambda capture|Захват переменных|`[&x, y]`|
|`[ ]`|Атрибуты|Атрибуты стандарта|`[[nodiscard]]`|
|`[ ]`|operator[]|Перегружаемый оператор|`obj[i]`|

---

|Символ|Где используется|Что означает|Пример|
|---|---|---|---|
|`;`|Конец выражения|Завершает statement|`int x = 0;`|
|`;`|После struct/class|**Обязательно**|`struct A {};`|
|`;`|Пустой statement|Ничего не делает|`while(x--);` ⚠️|
|`;`|for|Разделитель частей|`for(;;)`|

---

## Критические правила (без компромиссов)

1. **`{}` создаёт scope**, `()` — **выражение**
    
2. **`[]` ≠ `{}`**  
    `{}` — инициализация, `[]` — доступ
    
3. **`struct / class` всегда с `;`**
    
4. **Каждый statement заканчивается `;`**
    
5. `if / for / while` — `;` **НЕ ставится**
    
6. `while(...);` — почти всегда баг
    

---

## Минимальный эталон

```cpp
if (cond) {
    foo(x[i]);
}

struct A {
    int x{0};
};
```

Это вся картина..

Разбираем **инициализацию структуры**. Коротко, чётко, без мифов.

---

## Исходные данные

```cpp
struct A {
    int x;
    int y;
};
```

---

## Все корректные способы инициализации

### 1. **Brace-initialization (РЕКОМЕНДОВАНО)**

```cpp
A a{35, 5};
```

- Поля инициализируются **по порядку объявления**
    
- Нет narrowing
    
- Работает всегда
    

---

### 2. Copy-list-initialization

```cpp
A a = {35, 5};
```

- То же самое, что выше
    
- Разница минимальная
    
- Чуть слабее защита от narrowing
    

---

### 3. Value-initialization

```cpp
A a{};
```

- Все поля → `0`
    
- Без мусора
    

---

### 4. Aggregate initialization (что это вообще)

`struct A` — **aggregate**, если:

- нет пользовательских конструкторов
    
- нет private полей
    
- нет базовых классов
    

→ инициализация через `{}` работает автоматически.

---

## Чего НЕЛЬЗЯ

```cpp
A a(35, 5);   // ❌ нет конструктора
```

Скобки `()` **НЕ работают** для агрегатов.

---

## C++20: designated initializers

```cpp
A a{ .y = 5, .x = 35 };
```

- Порядок не важен
    
- Явно
    
- Только aggregate
    

---

## Ответ на твой комментарий в коде

```cpp
A hui = A{35, 5};   // ✅ правильный вариант
```

или короче:

```cpp
A hui{35, 5};       // ✅ лучший стиль
```

---

## Выжимка для конспекта

```cpp
A a{...};        // всегда можно
A a = {...};     // можно
A a(...);        // нельзя без ctor
```

---

## Жёсткое правило

> Для структур без конструктора — **только `{}`**  
> `()` — только если есть конструктор