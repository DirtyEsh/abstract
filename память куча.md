Странные понятия Ж: стек , фрейм стека
в структуре все распидаливается до наибольшей переменной.
Стек - авто память {}


с точки зрения компилятора - это разыменованый указатель
указатель - может быть nullptr, ссылка - нет .

Из лекции
pragma push? - но это сбивает **КЭШ ЛИНИИ**
в структуре все выравнивается в памяти по наибольшему 
но есть

против стековой памяти - память в куче
В куче нужно постоянно следить что память удалена
до программы delete , но могут быть разные приколы из-за которых 

в конструкторе выделяем память в куче, в диструкторе - удаляем
есть разные обертки 

!!умные указатели 
**ОТЛАДЧИКОМ НАУЧИТЬСЯ ПОЛЬЗОВАТЬСЯ
РАСШИРЕНИЕ ДЛЯ ПАМЯТИ**
Указател на стеке - память в куче , разыменовывание указателя - данные в куче

статические глобальные переменные с ин или без кладут в data Или baze
статические преременные создаются при первом вызове , а уничтожаются при закрытии программы
глобальные переменные в начале и также удаляются в конце.


указатель - адрес первого байта памяти на который он указывает 

![[Pasted image 20260218194927.png]]
приведение указателей 
![[Pasted image 20260218195011.png]]
перекладывает с одного типа на другой 
UB - меняем память которая нам не принадлежит - это то что может произойти при приведении.

Арифметика указателя
если мы прибавляем к указателю 1 шаг он равен размеру типа с которым мы работаем в данный момент (важно при работе с сырой памятью)

Вначале идет структура, потом ее поля 
поэтому к риватному движу можно достучаться через указатели плюсуя
![[Pasted image 20260218200711.png]]
тут мы берем структуру и приводим ее к иннту и топаем к ее приватным полям)))
НО при приведение обрубаются, лучше шагать в том же типе
Копирование данных и копирование указателей разные вещи 
![[Pasted image 20260218202006.png]]
