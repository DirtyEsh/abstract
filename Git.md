Ок. **Ультимативный гайд по Git**. Не “учебник”, а **рабочая ментальная модель + минимальный набор команд**, чтобы ты понимал, что происходит и не стрелял себе в ногу.
[[команды]]
---

## 0. Что такое Git на самом деле

Git — это **менеджер снимков состояния проекта**.

- не “менеджер файлов”
    
- не “облако”
    
- не “про синхронизацию”
    

Каждый коммит = **снимок всего проекта + ссылка на предыдущий**.

```text
A → B → C → D
```

Всё.

---

## 1. Три состояния Git (это база)

У Git всегда есть **3 зоны**:

```text
working directory  →  staging area  →  repository
(файлы)               (index)          (commits)
```

### Команды:

```bash
git status        # смотри, где что
git add file.cpp  # working → staging
git commit        # staging → commit
```

Если ты это понял — ты уже лучше 60% людей.

---

## 2. Коммит — атом реальности

Коммит:

- фиксирует **осмысленное изменение**
    
- не обязан компилироваться (но должен быть логически цельным)
    
- подписывается сообщением
    

```bash
git commit -m "Fix division by zero in model"
```

Плохой коммит:

```text
"changes"
"fix"
"upd"
```

---

## 3. Ветка — это указатель, а не копия

Ветка = **указатель на коммит**.

```text
A---B---C   ← main
```

Создал ветку:

```bash
git switch -c feature
```

```text
A---B---C
        ↑
     feature
```

Никаких копий файлов.  
Один репозиторий. Одна история. Разные указатели.

---

## 4. HEAD — где ты сейчас

`HEAD` = “где я стою”.

```bash
git status
# On branch main
```

Коммиты всегда идут **в текущую ветку**.

---

## 5. Merge — схлопывание реальностей

Merge = **объединение двух историй**.

```text
A---B---C   ← main
     \
      D---E ← feature
```

```bash
git switch main
git merge feature
```

Варианты:

- **fast-forward** — просто сдвиг указателя
    
- **merge commit** — если истории разошлись
    
- **conflict** — Git честно сдаётся
    

---

## 6. Конфликт — это не ошибка

Конфликт =

> “я не знаю, какой код правильный”

```cpp
<<<<<<< HEAD
// вариант main
=======
// вариант feature
>>>>>>> feature
```

Ты:

- решаешь
    
- удаляешь маркеры
    
- `git add`
    
- `git commit`
    

Это **нормальная работа**, не провал.

---

## 7. Rebase — переписать прошлое

Rebase = “перепроиграть мои коммиты поверх другого состояния”.

```bash
git rebase main
```

Используют:

- чтобы история была линейной
    
- в feature-ветках
    

**Никогда**:

- в общем `main`
    
- в ветке, которую уже забрали другие
    

---

## 8. Remote — другие репозитории

Обычно:

```text
origin   → твой GitHub
template → исходный шаблон
```

Команды:

```bash
git fetch origin    # забрать изменения (без merge)
git pull            # fetch + merge
git push            # отправить свои коммиты
```

---

## 9. PR — процесс, не команда

Pull Request:

- не ветка
    
- не merge
    
- **запрос на вливание ветки**
    

Даёт:

- код-ревью
    
- CI
    
- защиту `main`
    

---

## 10. CI — автоматический судья

CI:

- живёт на сервере
    
- запускается на push / PR
    
- собирает
    
- гоняет тесты
    
- говорит “можно” или “нельзя”
    

CI **не думает**, он исполняет скрипт.

---

## 11. Force push — ядерная кнопка

```bash
git push --force
```

Переписывает историю.

Использовать:

- только в своей ветке
    
- только если понимаешь последствия
    

Лучше:

```bash
git push --force-with-lease
```

---

## 12. Золотые правила Git

1. **Коммить часто, но осмысленно**
    
2. **Не force-push в общий `main`**
    
3. **Конфликт — это нормально**
    
4. **PR — точка контроля**
    
5. **Git не магия, а граф коммитов**
    

---

## 13. Минимальный набор команд “на всю жизнь”

```bash
git status
git add
git commit
git switch
git merge
git rebase
git fetch
git pull
git push
git log --oneline --graph
```

Всё остальное — производные.

---

## 14. Если кратко философски

- Git хранит **историю решений**
    
- ветки — **параллельные мысли**
    
- merge — **осознанный выбор**
    
- CI — **беспристрастный проверяющий**
    
- PR — **социальный контракт**
    

Если ты это понял — ты не “пользователь Git”, ты **контролируешь инструмент**.