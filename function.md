Короткий, **ультимативный конспект по `std::function`**. Без лирики.

---

# `std::function` — выжимка

## Что это

`std::function` — **обёртка для любого callable** с заданной сигнатурой  
(type-erasure).

```cpp
std::function<R(Args...)>
```

---

## Что можно хранить

- обычную функцию
    
- лямбду (с захватом и без)
    
- функтор (`operator()`)
    
- `std::bind` (не рекомендуется)
    

---

## Что подключать

```cpp
#include <functional>
```

---

## Базовое использование

```cpp
std::function<void(int)> f;

f = [](int x) {
    std::cout << x;
};

f(10);
```

---

## Сигнатура = контракт

```cpp
std::function<int(int, int)> add =
    [](int a, int b) { return a + b; };
```

- тип возвращаемого значения и аргументы **обязаны совпадать**
    
- неявные преобразования минимальны
    

---

## Проверка на пустоту

```cpp
if (f) {
    f(1);
}
```

Пустой вызов → `std::bad_function_call`

---

## Где использовать

✅ **Хранить callback**  
✅ **Публичные API / интерфейсы**  
✅ **События, сигналы, обработчики**

```cpp
class Button {
    std::function<void()> on_click;
};
```

---

## Где НЕ использовать

❌ горячие циклы  
❌ `std::sort`  
❌ шаблонные алгоритмы  
❌ где важна производительность

---

## Почему медленнее

- type-erasure
    
- возможна heap-аллокация
    
- виртуальный вызов
    

---

## Типичная ловушка (lifetime)

```cpp
std::function<void()> f;

{
    int x = 10;
    f = [&]() { std::cout << x; };
}
// x уничтожен → UB
```

---

## Альтернатива (если можно)

```cpp
template<class F>
void run(F&& f) {
    f();
}
```

Zero-cost.

---

## Выжимка (запомнить)

- `#include <functional>`
    
- `std::function<R(Args...)>`
    
- хранит **любой callable**
    
- медленный, но удобный
    
- проверяй `if (f)`
    
- следи за lifetime захватов