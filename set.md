
```
#include <set>
```
[[отсортированные множества]]

Контейнер `std::set` имеет второе распространённое название — **множество**, указывающее на то, что он может содержать только уникальные значения.
```
std::set birds = { "зяблик"s, "синица"s, "снегирь"s, "зяблик"s, "синица"s }; // birds = {"зяблик", "синица", "снегирь"}.
```
Как и в словарях, элементы множества хранятся упорядоченно в виде красно-чёрного дерева.
**Деревом** называют особую структуру данных, в которой элементы связаны друг с другом как «родительские» и «дочерние» узлы. В **красно-чёрном дереве** родительские и дочерние элементы упорядочены особым образом, что гарантирует быстрое выполнение операций вставки, удаления и поиска.
![[Pasted image 20260223025314.png]]
Ключами для сортировки являются сами значения элементов — поэтому `std::set` считается ассоциативным контейнером, несмотря на отсутствие явных ключей для обращения к элементам.

Такой способ хранения позволяет быстро находить значения и предотвращать дублирование.

Для `std::set` доступно большинство базовых операций: добавление и удаление элементов, а также проверка их наличия. Этот контейнер редко используется для доступа к конкретному значению, поэтому у него нет операции взятия по индексу или по ключу. При необходимости нужный элемент можно извлечь с помощью итераторов.

Чтобы узнать, есть ли элементы в множестве и сколько их, можно использовать знакомые вам методы `empty` и `size`.

```
std::set words = {
    "world"s, "hello"s, "hello"s
};
    
if (!words.empty()) {
    std::cout << "Множество не пустое. Количество элементов = "s 
              << words.size() << std::endl;
}
// Множество не пустое. Количество элементов = 2. 
```

Для добавления новых элементов в `std::set` есть метод `insert`, который работает аналогично методу `insert` для `std::map`. Он позволяет вставлять значения, которые будут сохранены только в том случае, если их ещё не было в множестве.

```
std::set years = {1917, 1984};

years.insert(1561); // Ок: это новый элемент.
years.insert(1984); // Этот элемент не будет добавлен.

// years = {1561, 1917, 1984}. 
```

Результат операции можно узнать по значениям, которые возвращает `insert`: итератору, указывающему на место нового элемента, и флагу, равному `true`, если элемент успешно добавлен.

```
auto [iterator, is_inserted] = years.insert(1984);
    
if (is_inserted) {
    std::cout << "Добавлен год: "s << *iterator;
} else {
    std::cout << "Этот год уже записан!"s;
} 
```

### Работа с элементами

Одна из самых частых операций с `std::set` — это проверка наличия элемента. Её можно выполнить с помощью метода `contains`, который возвращает логическое значение.

```C++
std::set words = {
    "hello"s, "world"s, "hello"s
};

auto word = "hello"s;
if (words.contains(word)) {
    std::cout << "Слово уже есть"s << std::endl;
} 
```

Второй способ — метод `find`, возвращающий итератор, указывающий либо на найденное слово, либо на конец контейнера, если поиск оказался неудачным.

```
auto word = "hello"s;
auto iter = words.find(word);

if (iter != words.end()) {
    std::cout << "Слово уже есть"s << std::endl;
} 
```

Ещё одна полезная операция — перебор элементов множества. Как и в случае с `std::map`, это можно сделать как с помощью итераторов, так и обращаясь к значениям напрямую через ссылку.

```
// Перебор через итераторы.
for (auto iter = words.begin(); iter!= words.end(); ++iter) {
    std::cout << *iter << std::endl;
}

// Перебор через ссылку.
for (const auto& word : words) {
    std::cout << word << std::endl;
}
// Вывод:
// hello
// world 
```

В обоих случаях значение (итератор или ссылка), которое участвует в цикле, является константным. Через него нельзя менять элементы множества.

```
for (auto iter = words.begin(); iter!= words.end(); ++iter) {
    *iter = "another"s; // Ошибка!
} 
```

Изменение значений — сложная операция, которая потребовала бы перестроения всего «дерева» (структуры данных). Вместо этого можно удалить ненужный элемент и добавить в множество новый. Удаление выполняется с помощью метода `erase`, который может работать и со значениями, и с итераторами.

```
// Удаление по значению.
words.erase("hello"s);

// Удаление по итератору.
words.erase(words.find("hello"s)); 
```

Если указанный элемент нашёлся в контейнере и был успешно удалён, `erase` возвращает `true`.

```
auto is_erased = words.erase("hello"s);
    
if (is_erased) {
    std::cout << "Элемент был удалён"s << std::endl;
} 
```

для сложных элементов важно наличие компаратора которое позволит упорядочить элементы

```c
class User {
public:
    User(std::string name, int rd) : name_(name), registration_date_(rd) {}
    
    int GetRegDate() const {
        return registration_date_;
    }
private:
    std::string name_;
    int registration_date_;
};
-------here comporator initional how functor--------------------

struct UserComparator {
    bool operator() (const User& u1, const User& u2) const {
        return u1.GetRegDate() < u2.GetRegDate();
    }
};

...

std::set<User, **UserComparator** > set_of_users{
    User ("Alice"s, 20240907),
    User ("Bobby"s, 20190115),
    User ("Charlie"s, 20220910),
    User ("Mary"s, 20220910),
};
Здесь уквзывается компоратор в инициализации 
// set_of_users = { 
// ("Bobby", 20190115), 
// ("Charlie", 20220910), 
// ("Alice", 20240907) 
// }
```

В приведённом примере компаратор `UserComparator` задаёт правило для сравнения объектов типа `User`: они будут упорядочены по дате регистрации (поле `registration_date_`). Поскольку у пользователей Charlie и Mary даты совпадают, они считаются одинаковыми элементами, и множество сохранит только один из них.

### Преобразование одних контейнеров в другие

В библиотеке STL предусмотрена возможность создавать новые контейнеры на основе пары итераторов из уже существующих контейнеров. Например, таким образом можно получить `std::set` из элементов вектора.

```
std::vector vec{1, 1, 2, 2, 3, 4, 5, 6};

// Создадим множество из элементов вектора.  
auto unique_elements = std::set<int>(vec.begin(), vec.end());

for (auto item : unique_elements) {
    std::cout << item << " "s;
} 
//Вывод: 1 2 3 4 5 6 . 
```

Аналогично можно выполнить и обратное преобразование, создав вектор из элементов множества.

```
std::set set{'a', 'b', 'c', 'd'};
auto vec = std::vector<char>(set.begin(), set.end());

for (auto item : vec) {
    std::cout << item << " "s;
} 
//Вывод: a b c d . 
```

При объявлении нового контейнера конструктор получает два параметра — итераторы, указывающие на начало и конец диапазона, которые не обязательно должны совпадать с итераторами `begin` и `end`.

```
// Выберем элементы от 'a' до 'с' (не включительно).
auto vec = std::vector<char>(set.begin(), set.find('c'));

// vec = ['a', 'b']. 
```

Подобные преобразования возможны и для других контейнеров — главное, чтобы их элементы были одного типа. Например, превратить множество в словарь не получится, поскольку элементы словаря должны быть парами. Зато это свойство позволяет создавать новые словари на основе существующих, в том числе с новыми компараторами.

При объявлении нового контейнера конструктор получает два параметра — итераторы, указывающие на начало и конец диапазона, которые не обязательно должны совпадать с итераторами `begin` и `end`.

```
// Выберем элементы от 'a' до 'с' (не включительно).
auto vec = std::vector<char>(set.begin(), set.find('c'));

// vec = ['a', 'b']. 
```

Подобные преобразования возможны и для других контейнеров — главное, чтобы их элементы были одного типа. Например, превратить множество в словарь не получится, поскольку элементы словаря должны быть парами. Зато это свойство позволяет создавать новые словари на основе существующих, в том числе с новыми компараторами.

В следующем примере мы создадим словарь `new_accounts` с другим правилом сортировки: вместо того, чтобы упорядочивать числовые значения по возрастанию, он будет сравнивать ключи лексикографически.


## По сути здесь рассматривается то как отсортировать тот же контейнер по-иному

```
struct Comparator{
    bool operator()(int a, int b) const {
        return std::to_string(a) < std::to_string(b);
    }
};

...
// Словарь со стандартным компаратором.
std::map<int, std::string> accounts {
    {1000000, "Jeff"s}, 
    {5555, "Mary"s},
    {90000, "Jeff"s},
};


// Создадим на его основе новый словарь с Comparator.    
auto new_accounts = std::map<int, std::string, Comparator>(
                             accounts.begin(), accounts.end());

// В первом варианте элементы сортируются по возрастанию числовых ключей:
// 5555, Mary
// 90000, Jeff
// 1000000, Jeff
    
// Во втором варианте ключи сортируются как строки:
// 1000000, Jeff
// 5555, Mary
// 90000, Jeff 
```