### Сравниваем диапазоны

Векторы, как и `std::tuple`, можно сравнивать, используя при этом все возможные операции сравнения: `<`, `>`, `<=`, `>=`, `==`, `!=` и `<=>`. При этом сравнение происходит лексикографически:

```cpp
// Различие в этом элементе:     ↓
std::vector<int> v1{100, 200, 3, 4, 5};
std::vector<int> v2{100, 200, 3, 2, 1, 0};

std::cout << std::boolalpha; // Манипулятор для вывода bool.

std::cout << "v1 < v2: " << (v1 < v2) << std::endl;
std::cout << "v1 > v2: " << (v1 > v2) << std::endl;
std::cout << "v1 <= v2: " << (v1 <= v2) << std::endl;
std::cout << "v1 >= v2: " << (v1 >= v2) << std::endl;
std::cout << "v1 != v2: " << (v1 != v2) << std::endl;
std::cout << "v1 == v2: " << (v1 == v2) << std::endl;

// Получим:
// v1 < v2: false
// v1 > v2: true
// v1 <= v2: false
// v1 >= v2: true
// v1 != v2: true
// v1 == v2: false 
```

В отличие от `std::tuple` в этой ситуации вектор является **префиксом**, то есть началом другого вектора. Здесь более короткий вектор считается меньшим, чем более длинный:

```cpp
std::vector<std::string> v1{"I", "love", "C++"};
std::vector<std::string> v2{"I", "love", "C++", "very", "much"};

std::cout << std::boolalpha;

// Вектор v1 – префикс v2 и поэтому v1 меньше.
std::cout << "v1 < v2: " << (v1 < v2) << std::endl; // true. 
```
---
Если необходимо сравнивать не векторы целиком, а диапазоны, заданные парами итераторов, для такой задачи подойдут следующие алгоритмы:

- `std::equal` для проверки на равенство;
- `std::lexicographical_compare` для проверки на неравенство;
- `std::lexicographical_compare_three_way` для трехстороннего сравнения диапазонов (операции `<=>`).
  
  # Объяснение алгоритмов сравнения диапазонов с примерами

## 1. **`std::equal`** — проверка на равенство диапазонов

### Объяснение:
Сравнивает два диапазона поэлементно. Возвращает `true`, если:
- Все элементы равны (по `operator==` или переданному предикату)
- Диапазоны имеют одинаковую длину

### Сигнатуры:
```cpp
// Простейшая форма (сравнивает до last1)
template<class InputIt1, class InputIt2>
bool equal(InputIt1 first1, InputIt1 last1,
           InputIt2 first2);

// С предикатом сравнения
template<class InputIt1, class InputIt2, class BinaryPredicate>
bool equal(InputIt1 first1, InputIt1 last1,
           InputIt2 first2, BinaryPredicate p);

// С указанием обоих концов (проверяет и длину)
template<class InputIt1, class InputIt2>
bool equal(InputIt1 first1, InputIt1 last1,
           InputIt2 first2, InputIt2 last2);
```

### Пример с Package:
```cpp
#include <algorithm>
#include <vector>

std::vector<Package> post1_packages;
std::vector<Package> post2_packages;

// 1. Сравнение по умолчанию (использует operator== для Package)
bool identical = std::equal(
    post1_packages.begin(), post1_packages.end(),
    post2_packages.begin()
);
// true если все посылки одинаковые

// 2. Сравнение только по весу
bool same_weights = std::equal(
    post1_packages.begin(), post1_packages.end(),
    post2_packages.begin(),
    [](const Package& a, const Package& b) {
        return a.weight == b.weight;  // Игнорируем отправителя/получателя
    }
);

// 3. Проверка с учётом длины диапазонов
bool fully_equal = std::equal(
    post1_packages.begin(), post1_packages.end(),
    post2_packages.begin(), post2_packages.end()
);
// Вернёт false если векторы разной длины
```

---

## 2. **`std::lexicographical_compare`** — лексикографическое сравнение

### Объяснение:
Сравнивает диапазоны как слова в словаре (лексикографически):
1. Сравнивает первые элементы
2. Если они равны — переходит к следующим
3. Возвращает `true`, если первый диапазон "меньше" второго

### Сигнатуры:
```cpp
// Использует operator<
template<class InputIt1, class InputIt2>
bool lexicographical_compare(InputIt1 first1, InputIt1 last1,
                             InputIt2 first2, InputIt2 last2);

// С кастомным компаратором
template<class InputIt1, class InputIt2, class Compare>
bool lexicographical_compare(InputIt1 first1, InputIt1 last1,
                             InputIt2 first2, InputIt2 last2,
                             Compare comp);
```

### Пример:
```cpp
std::vector<Package> morning_deliveries;
std::vector<Package> evening_deliveries;

// 1. Лексикографическое сравнение по умолчанию
bool morning_first = std::lexicographical_compare(
    morning_deliveries.begin(), morning_deliveries.end(),
    evening_deliveries.begin(), evening_deliveries.end()
);
// Использует operator< для Package

// 2. Сравнение только по весу (как в словаре весов)
bool lighter_first = std::lexicographical_compare(
    morning_deliveries.begin(), morning_deliveries.end(),
    evening_deliveries.begin(), evening_deliveries.end(),
    [](const Package& a, const Package& b) {
        return a.weight < b.weight;
    }
);

// Пример с числами для ясности:
std::vector<int> v1 = {1, 2, 3};
std::vector<int> v2 = {1, 2, 4};
// v1 < v2, потому что на позиции 2: 3 < 4

std::vector<int> v3 = {1, 2, 3, 0};  // длиннее
std::vector<int> v4 = {1, 2, 3};
// v4 < v3, потому что v4 короче (префикс равен, но v4 закончился раньше)
```

---

## 3. **`std::lexicographical_compare_three_way`** — трёхстороннее сравнение (C++20)

### Объяснение:
Улучшенная версия для C++20, возвращает не просто `true/false`, а результат сравнения:
- `std::strong_ordering::less`
- `std::strong_ordering::equal`
- `std::strong_ordering::greater`

### Сигнатуры:
```cpp
// Использует operator<=>
template<class InputIt1, class InputIt2>
auto lexicographical_compare_three_way(InputIt1 first1, InputIt1 last1,
                                       InputIt2 first2, InputIt2 last2);

// С кастомным трёхсторонним компаратором
template<class InputIt1, class InputIt2, class Cmp>
auto lexicographical_compare_three_way(InputIt1 first1, InputIt1 last1,
                                       InputIt2 first2, InputIt2 last2,
                                       Cmp comp);
```

### Пример:
```cpp
// Допустим, у Package есть operator<=>, сравнивающий по весу
auto cmp_result = std::lexicographical_compare_three_way(
    post1_packages.begin(), post1_packages.end(),
    post2_packages.begin(), post2_packages.end()
);

// Результат можно использовать в switch или if
if (cmp_result < 0) {
    std::cout << "post1_packages лексикографически меньше\n";
} else if (cmp_result == 0) {
    std::cout << "Диапазоны равны\n";
} else { // cmp_result > 0
    std::cout << "post1_packages лексикографически больше\n";
}

// С кастомным сравнением
auto weight_cmp = std::lexicographical_compare_three_way(
    post1_packages.begin(), post1_packages.end(),
    post2_packages.begin(), post2_packages.end(),
    [](const Package& a, const Package& b) {
        return a.weight <=> b.weight;  // Сравниваем только по весу
    }
);
```

## Когда что использовать:

| Алгоритм | Когда использовать | Возвращает |
|----------|-------------------|------------|
| `std::equal` | Проверить полное равенство | `bool` |
| `std::lexicographical_compare` | Упорядочить диапазоны (сортировка, поиск) | `bool` |
| `std::lexicographical_compare_three_way` | Точное сравнение с C++20 | `ordering` |

## Практический пример для Post:
```cpp
class Post {
public:
    // Сравнение двух отделений по общему весу посылок
    bool operator<(const Post& other) const {
        return CalculateTotalWeight() < other.CalculateTotalWeight();
    }
    
    // Проверка, одинаковые ли посылки в двух отделениях
    bool HasSamePackages(const Post& other) const {
        if (packages_.size() != other.packages_.size()) return false;
        
        return std::equal(
            packages_.begin(), packages_.end(),
            other.packages_.begin(),
            [](const Package& a, const Package& b) {
                return a.sender == b.sender &&
                       a.addressee == b.addressee &&
                       a.weight == b.weight;
            }
        );
    }
};
```

### Наведём порядок

Вы уже знаете, что алгоритм `std::sort` позволяет упорядочить последовательность. Для его использования необходимо подключать `<algorithm>`. Чтобы определить, как должны быть расположены элементы после `std::sort`, задаётся **отношение порядка** — условие, при котором один элемент нужно располагать раньше другого при сортировке. Для этого нужен компаратор.

---

# Конспект: `std::sort`

## Синтаксис
```cpp
#include <algorithm>

// 1. По умолчанию (возрастание, использует operator<)
template<typename RandomIt>
void sort(RandomIt first, RandomIt last);

// 2. С компаратором
template<typename RandomIt, typename Compare>
void sort(RandomIt first, RandomIt last, Compare comp);
```

## Примеры

### Базовые
```cpp
// Числа по возрастанию
std::vector<int> v = {3, 1, 4, 1, 5};
std::sort(v.begin(), v.end());  // 1, 1, 3, 4, 5

// По убыванию
std::sort(v.begin(), v.end(), std::greater<int>());  // 5, 4, 3, 1, 1
```

### С лямбдами
```cpp
// Пользовательские типы
struct Package { double weight; std::string sender; };

std::vector<Package> packages;

// По весу
std::sort(packages.begin(), packages.end(),
          [](const Package& a, const Package& b) {
              return a.weight < b.weight;  // Less
          });

// По отправителю (лексикографически)
std::sort(packages.begin(), packages.end(),
          [](const Package& a, const Package& b) {
              return a.sender < b.sender;
          });
```

### Многокритериальная сортировка
```cpp
// Сначала по отправителю, потом по весу
std::sort(packages.begin(), packages.end(),
          [](const Package& a, const Package& b) {
              if (a.sender != b.sender)
                  return a.sender < b.sender;
              return a.weight < b.weight;
          });
```

## Что такое Less?

**Less** — это **строгий слабый порядок**:
- `comp(a, a)` всегда `false` (иррефлексивность)
- Если `comp(a, b)` и `comp(b, c)`, то `comp(a, c)` (транзитивность)

```cpp
// Правильный Less для сортировки по возрастанию
[](int a, int b) { return a < b; }

// НЕправильный Less (нарушает транзитивность)
[](int a, int b) { return a <= b; }  // ОШИБКА!
```

## Функциональные объекты из `<functional>`
```cpp
#include <functional>

std::sort(v.begin(), v.end(), std::less<int>());      // возрастание
std::sort(v.begin(), v.end(), std::greater<int>());   // убывание
std::sort(v.begin(), v.end(), std::greater_equal<int>());  // ОШИБКА! Не Less
```

## Для пользовательских типов
```cpp
struct Package {
    double weight;
    
    // 1. Оператор <
    bool operator<(const Package& other) const {
        return weight < other.weight;
    }
    
    // 2. Функциональный объект
    struct WeightLess {
        bool operator()(const Package& a, const Package& b) const {
            return a.weight < b.weight;
        }
    };
};

// Использование
std::vector<Package> packages;
std::sort(packages.begin(), packages.end());  // через operator<
std::sort(packages.begin(), packages.end(), Package::WeightLess());
```

## Особенности
- **Требует**: RandomAccessIterator (`vector`, `deque`, `array`)
- **Сложность**: O(N·log(N))
- **Нестабильный**: равные элементы могут менять порядок
- **Для стабильной сортировки**: `std::stable_sort`

## Проверка сортировки
```cpp
bool sorted = std::is_sorted(v.begin(), v.end());
bool sorted_desc = std::is_sorted(v.begin(), v.end(), std::greater<int>());
```

**Правило**: компаратор должен возвращать `true`, если первый аргумент должен идти **раньше** второго в отсортированной последовательности.

# Стандартные компараторы из `<functional>`

## Базовые арифметические

cpp

std::sort(vec.begin(), vec.end(), std::less<int>());       // a < b (по умолчанию)
std::sort(vec.begin(), vec.end(), std::greater<int>());    // a > b
std::sort(vec.begin(), vec.end(), std::less_equal<int>()); // a <= b
std::sort(vec.begin(), vec.end(), std::greater_equal<int>()); // a >= b

**Внимание:** Только `less` и `greater` подходят для сортировки!`



std::reverse(teams.begin(), teams.end()); -  развернет вектор 

---
std::reverse(teams.begin(), teams.end());
```cpp
std::unique
auto to_del = std::unique(some_vec.begin(), some_vec.end());
//ставит все повторяющиеся элементы в конец, чтобы итератор не терял валидность
some_vec.erase(to_del, some_vec.end());
//удаляет все с ^ возвращенного итератора
```
Похожим образом действуют алгоритмы `std::remove` и `std::remove_if`. Они не удаляют элементы, а переставляют их в конец. Но при этом возвращают итератор на то место, с которого нужно удалять.

```cpp
std::vector<int> vec = {4, 2, 6, 3, 1, 5, 3, 2, 15, 0, 3, 1};

// Удалим двойки.
auto to_del = std::remove(vec.begin(), vec.end(), 2);
vec.erase(to_del, vec.end());
// vec == {4, 6, 3, 1, 5, 3, 15, 0, 3, 1};

// Удалим нечётные числа.
auto to_del2 = std::remove_if(vec.begin(), vec.end(), [](int i){
    return i % 2 != 0;
});
vec.erase(to_del2, vec.end());
// vec == {4, 6, 0}; 
```
---
Вот пример последовательности из 10 чисел от 1 до 1 000 000, полученной генератором псевдослучайных чисел: 137417, 594628, 635917, 656650, 816188, 605287, 364793, 421639, 394494, 737286.

Такие последовательности кажутся хаотичными и непредсказуемыми, для этого даже существуют математические критерии. Но эти числа всё равно сгенерированы однозначным алгоритмом. Один из самых известных таких алгоритмов — **вихрь Мерсенна**. Для использования его в C++ существует тип `std::mt19937` из заголовочного файла `<random>`.

`// Создадим генератор.`
`std::mt19937 gen;`

`// Нам нужны числа от 1 до 1 000 000.`
`std::uniform_int_distribution<> dist(1, 1'000'000);`

`// Создаём вектор для хранения случайны- 
**`std::uniform_int_distribution<>`** - распределение, которое "превращает" сырые случайные числа в равномерно распределенные целые числа в заданном диапазонех чисел из пяти элементов.`
`std::vector<int> random_numbers(5);`


`// И заполним его случайными числами.`
`for (auto& num : random_numbers) {`
    `num = dist(gen);`
`}`
---

Чтобы получать из генератора `gen` числа в определённом диапазоне, нам понадобилось создать распределение `dist`. Объект класса `uniform_int_distribution` позволяет получать из генератора целые числа в некотором диапазоне, причём все числа появляются с равной вероятностью.

При запуске этой программы вы получите такую последовательность: 814724, 135478, 905792, 835009, 126987. Как вы можете заметить, последовательность будет всегда одна и та же. Чтобы изменить её, можно поменять **сид** (от англ. `seed` — зерно). Сид задаётся в конструкторе генератора и может кардинально изменить числа, которые вы получите:

```
// Используем сид 1:
std::mt19937 gen(1);

std::uniform_int_distribution<> dist(1, 1'000'000);
std::vector<int> random_numbers(5);
for (auto& num : random_numbers) {
    num = dist(gen);
}

// Теперь в векторе будут числа 417022, 997185, 720325, 932558, 115. 
```

Но так мы всё равно не получим случайность, ведь сид жёстко задан в коде. Однако есть ещё один способ получить случайный сид — **аппаратный генератор** случайного значения. В C++ он задан классом `std::random_device`. Объект этого класса позволяет получать невоспроизводимое число на основе системного времени и других характеристик оборудования. Этот способ получения псевдослучайных чисел намного медленней и его не рекомендуется использовать для логики программы. Но можно использовать для получения сида:

```
// Аппаратный генератор случайного значения:
std::random_device rd;   

// Инициализация начальным значением, полученным от аппаратного генератора:
std::mt19937 gen(rd());  
```

аполним вектор значениями. std::vector<int> numbers{1, 2, 3, 4, 5, 6}; // Создание генератора со случайным начальным значением. 
std::random_device rd; std::mt19937 gen_shuffle(rd()); // Перемешаем элементы в векторе. std::shuffle(numbers.begin(), numbers.end(), gen_shuffle)