## Операции над `std::set` в STL

`std::set` сам по себе **не имеет методов** `intersection / union / difference`.  
Операции над множествами реализованы как алгоритмы из `<algorithm>`.

---

# Что подключать

```cpp
#include <set>
#include <algorithm>
#include <iterator>
```

---

# Требования

Алгоритмы работают с **отсортированными диапазонами**.

Для `std::set` это выполняется автоматически:

- элементы уникальны
    
- элементы отсортированы
    
- используется один и тот же компаратор
    

Сложность всех операций:

```
O(n + m)
```

где `n = a.size()`, `m = b.size()`

---

# 1️⃣ `std::set_intersection`

Пересечение — элементы, которые есть в обоих множествах.

```cpp
std::set<int> result;

std::set_intersection(
    a.begin(), a.end(),
    b.begin(), b.end(),
    std::inserter(result, result.end())
);
```

---

# 2️⃣ `std::set_union`

Объединение — все уникальные элементы из обоих множеств.

```cpp
std::set_union(
    a.begin(), a.end(),
    b.begin(), b.end(),
    std::inserter(result, result.end())
);
```

---

# 3️⃣ `std::set_difference`

Разность — элементы, которые есть в `a`, но отсутствуют в `b`.

```cpp
std::set_difference(
    a.begin(), a.end(),
    b.begin(), b.end(),
    std::inserter(result, result.end())
);
```

---

# 4️⃣ `std::set_symmetric_difference`

Симметрическая разность — элементы, которые есть в одном из множеств, но не в обоих.

```cpp
std::set_symmetric_difference(
    a.begin(), a.end(),
    b.begin(), b.end(),
    std::inserter(result, result.end())
);
```

---

# Как это работает внутри

Алгоритмы используют **двойной линейный проход** (как merge в merge sort):

```
it1 → a.begin()
it2 → b.begin()

двигаем один или оба итератора,
сравнивая элементы
```

Без `contains`, без логарифмов.

---

# Важно помнить

- Алгоритмы **не создают контейнер сами** — они пишут в output-итератор.
    
- Для `std::set` всегда используем `std::inserter`.
    
- Компаратор у обоих множеств должен совпадать.
    

---

# Итог

`std::set` — контейнер.  
`set_*` — алгоритмы над отсортированными диапазонами.  
Использовать их — правильно и асимптотически оптимально.