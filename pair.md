Ок. **Ультимативный гайд по `std::pair`** — сжато, по делу, без воды.

---

# `std::pair<T1, T2>`

```cpp
#include <utility>
```

Хранит **ровно два значения**. Без логики. Без имён. Просто пара.

---

## Как создавать (ВСЕ нормальные способы)

### 1️⃣ Через конструктор (явно)

```cpp
std::pair<int, double> p(1, 3.14);
```

---

### 2️⃣ Через список инициализации

```cpp
std::pair<int, double> p{1, 3.14};
```

---

### 3️⃣ `std::make_pair` (старый, но живой)

```cpp
auto p = std::make_pair(1, 3.14);
```

- вывод типов
    
- decays (`int&` → `int`)
    

---

### 4️⃣ С `auto` + CTAD (C++17)

```cpp
std::pair p{1, 3.14};
```

---

## Доступ к элементам

```cpp
p.first;
p.second;
```

---

## Structured bindings (РЕКОМЕНДОВАНО)

```cpp
auto [x, y] = p;
```

- читабельно
    
- безопасно
    
- без `.first/.second`
    

---

## Где использовать (реально)

### 1️⃣ Возврат из функции (2 значения)

```cpp
std::pair<int, bool> parse();
```

---

### 2️⃣ `std::map`, `std::unordered_map`

```cpp
for (const auto& [key, value] : my_map) { }
```

---

### 3️⃣ Алгоритмы STL

```cpp
auto [min, max] = std::minmax(v.begin(), v.end());
```

---

### 4️⃣ Временная склейка данных

```cpp
std::pair<int, int> range{l, r};
```

---

## Сравнение

```cpp
p1 == p2;
p1 < p2;
```

Лексикографически:

- сначала `first`
    
- потом `second`
    

---

## `pair` vs `struct`

||`pair`|`struct`|
|---|---|---|
|Имена|❌ нет|✅ есть|
|Краткость|✅|❌|
|Семантика|слабая|сильная|
|API|STL|пользовательский|

**Правило:**

- временно → `pair`
    
- надолго → `struct`
    

---

## Чего НЕ делать

❌ использовать `pair` для сложной логики  
❌ хранить больше 2 значений  
❌ писать `first/second` в бизнес-коде (используй structured bindings)

---

## Железная выжимка

```
pair = 2 значения
.first / .second
make_pair / { }
лучше для возврата и STL
не для доменной логики
```

Если хочешь — следующим логично разобрать `std::tuple` vs `pair` или `tie` / `ignore` в том же формате.