
---
[[Signals]]  -generate
[[generate tramsform]]

---
Чтобы заполнять векторы с повторяющимся набором элементов, существует специальный алгоритм — `std::fill`. Он берёт два итератора и заполняет все элементы между ними нужным значением, которое указывается третьим параметром:
```cpp

// Конструктор создаст вектор из 20 букв a:
vector<string> repeat(20, "a");

// Напечатаем 20 a:
PrintVector(repeat);

// Заполним вектор буквами b и напечатаем 20 букв b:
std::fill(repeat.begin(), repeat.end(), "b");
PrintVector(repeat);

// Заполним начало буквами c и напечатаем 10 букв c и 10 букв b:
std::fill(repeat.begin(), repeat.begin() + 10, "c");
PrintVector(repeat);
```

> [!![[Pasted image 20260207232331.png]]] Title

```cpp
std::vector<int> meander(48000, 0);

// Заполним первые 200 отсчётов – одиночный меандр.
std::fill(meander.begin(), meander.begin() + 100, 10000);
std::fill(meander.begin() + 100, meander.begin() + 200, -10000);
```
Алгоритм `std::fill` не занимается созданием новых ячеек и изменением размера вектора.

У алгоритма `std::fill` есть напарник `std::fill_n`, он в качестве второго параметра принимает не итератор, а количество элементов. Как и `std::fill`, этот алгоритм проходит по элементам вектора, начиная от начального итератора и меняя значения:

```
std::fill_n(meander.begin(), 100, 10000); 
```

> [!![[Pasted image 20260207232614.png]]] Title
> 

Ультра-коротко. **Рид-бук формат.**

---

## `std::copy_n`

```cpp
#include <algorithm>
```

### Синтаксис

```cpp
std::copy_n(src, n, dst);
```

- `src` — итератор на начало источника
    
- `n` — сколько элементов копировать
    
- `dst` — итератор на начало назначения
    

---

### Пример

```cpp
std::vector<int> a{1,2,3,4,5};
std::vector<int> b(3);

std::copy_n(a.begin(), 3, b.begin());
// b = {1,2,3}
```

---

### Важно

- **НЕ проверяет границы**
    
- `dst` обязан указывать на **достаточно места**
    
- возвращает итератор **после последнего скопированного элемента**
    

```cpp
auto it = std::copy_n(a.begin(), 3, b.begin());
// it == b.begin() + 3
```

---

### Когда использовать

- нужен **фиксированный размер**
    
- быстрее и чище, чем `copy + advance`
    
- копирование “первых N элементов”
    

---

### Железная выжимка

```
copy_n → копирует ровно N
без проверок
dst должен быть готов
```

---
### std::back_inserter <- Специальный итератор
```
#include <iterator>
```

При использовании `std::back_inserter` происходит добавление элемента в нужный вектор, и в этом случае автоматически изменяется размер вектора. Вектор, в который нужно вставлять элементы, указывается в конструкторе итератора.

```cpp
//  Создадим вектор без указания количества элементов:
std::vector<int16_t> signal;

// Добавим 100 чисел 10000 в signal.
std::fill_n(std::back_inserter(signal), 100, 10000);
// Добавим ещё 100 чисел -10000.
std::fill_n(std::back_inserter(signal), 100, -10000);

std::cout << signal.size();
// Результат вывода на печать: 200.
```
У итератора `back_inserter` операции `++` и `*` ничего не делают. Поэтому запись `*(inserter++) = *(in_iter++);` эквивалентна `inserter = *(in_iter++);`. А вот присваивание переопределено — оно вызывает `push_back` контейнера. И в этом случае происходит добавление нового элемента в конец последовательности.

Однако, чтобы функция `ReplicateSignal` работала корректно, нужно добавить вызов `reserve` перед заполнением контейнера:

```
//  Создадим вектор без указания количества элементов:
std::vector<int> signal;
signal.reserve(48000);

// Добавим 100 чисел 10000 в signal.
... 
```

Без `reserve` в `ReplicateSignal` может

