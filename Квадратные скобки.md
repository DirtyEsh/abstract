Короткий **рид-бук по перегрузке `operator[]`**. Синтаксис, где можно, где нельзя, примеры.

---

## Главное правило

**`operator[]` перегружается ТОЛЬКО как метод класса.**  
Вне класса — **нельзя**.

---

## Базовый синтаксис (класс)

```cpp
class A {
public:
    T& operator[](size_t i);
};
```

### Пример

```cpp
class Buffer {
    std::vector<int> data;
public:
    int& operator[](size_t i) {
        return data[i];
    }
};
```

Использование:

```cpp
Buffer b;
b[0] = 42;
```

---

## `const` и `non-const` версии (ОЧЕНЬ ВАЖНО)

```cpp
class Buffer {
    std::vector<int> data;
public:
    int& operator[](size_t i) {
        return data[i];
    }

    const int& operator[](size_t i) const {
        return data[i];
    }
};
```

- без `const` → можно менять
    
- с `const` → только читать
    

```cpp
const Buffer cb;
int x = cb[0];   // OK
cb[0] = 5;       // ❌
```

---

## С проверкой границ

```cpp
int& operator[](size_t i) {
    if (i >= data.size())
        throw std::out_of_range("index");
    return data[i];
}
```

(по смыслу как `at()`)

---

## Не только индекс: любой тип

```cpp
class Dict {
    std::map<std::string, int> m;
public:
    int& operator[](const std::string& key) {
        return m[key];
    }
};
```

```cpp
Dict d;
d["age"] = 20;
```

---

## ВНЕ класса — НЕЛЬЗЯ ❌

```cpp
int& operator[](A& a, int i); // ❌ запрещено стандартом
```

`[]` **обязан** быть методом.

---

## Частая ошибка

```cpp
auto operator[](size_t i); // ❌ без ссылки — нельзя присваивать
```

Должно быть:

```cpp
T& operator[](size_t i);
```

---

## Когда перегружать `operator[]`

- контейнер
    
- доступ по индексу / ключу
    
- быстрый доступ без логики
    

❌ не для сложных вычислений  
❌ не для побочных эффектов

---

## Железная выжимка

```
operator[] → только метод класса
обычно возвращает T&
нужны const и non-const версии
вне класса — нельзя
```

Если нужно — дальше логично разобрать **proxy-объекты для `operator[]`** (как у `std::vector<bool>`), но это уже следующий уровень.