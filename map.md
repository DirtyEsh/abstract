Создадим пустой `std::map` для этой задачи.

```c
#include <map> // Подключаем для работы с контейнером.
#include <cstdint>

int main() {
    std::map<std::string, uint64_t> accounts;
} 
```

Контейнер — это шаблон, поэтому в угловых скобках `<>` нужно указать типы ключей и значений. В нашем случае ключами будут имена пользователей, а значениями — номера аккаунтов.

Как и другие контейнеры, `std::map` можно инициализировать сразу при создании.

```c
// Вариант 1.
std::map<std::string, uint64_t> accounts = {
    {"Jeff"s, 1000000},
    {"Bill"s, 9999999},
};

// Вариант 2.
std::map<std::string, uint64_t> accounts {
    {"Jeff"s, 1000000},
    {"Bill"s, 9999999},
}; 
```

Если в списке инициализации указано несколько значений с одинаковыми ключами, в словарь попадёт самое первое.

Доступ к элементам

Получить значение словаря можно с помощью операции взятия по индексу `[]`. Она же позволяет редактировать значения.

```c
std::cout << accounts["Mary"s] << std::endl; // Выведет 5555515.
    
accounts["Mary"s] = 700055555;
std::cout << accounts["Mary"s] << std::endl; // Выведет 700055555. 
```

Для проверки, есть ли элементы в словаре, существует метод `empty`, возвращающий логическое значение. Если нужно узнать точный размер словаря, можно использовать метод `size`.

## for
Несмотря на то что элементы в `std::map` не пронумерованы, их можно перебрать с помощью цикла `for`. Самый простой способ — использовать декомпозицию `auto& [key, value]`.

```c
std::map<std::string, uint64_t> accounts {
    {"Jeff"s, 1000000},
    {"Mary"s, 5555515},
    {"Bill"s, 9999999}
};
    
for (auto& [key, value]: accounts) {
    std::cout << key << ", "s << value << std::endl;
}   

// Вывод:
// Bill, 9999999
// Jeff, 1000000
// Mary, 5555515 
```

```
for (auto& [key, value]: accounts) { value = 0; } // Вывод: // Bill, 0 // Jeff, 0 // Mary, 0
```

## insert
Чтобы добавить в `std::map` элемент с новым ключом, используется метод `insert`. Он принимает один параметр — пару из ключа и значения.

```c
std::map<std::string, uint64_t> accounts {
    {"Mary"s, 5555515},
    {"Bill"s, 9999999},
};

// Добавим новые элементы.
accounts.insert({"Mark"s, 10101010101});
accounts.insert({"Bill"s, 100});

ShowAccounts(accounts);

// Вывод:
// Bill, 9999999
// Mark, 10101010101
// Mary, 5555515 
```

**Второе значение не попало в словарь, поскольку ключ `Bill` в нём уже есть. Метод `insert` не переписывает имеющиеся элементы.**

Чтобы убедиться, добавлен ли элемент в словарь, можно использовать значения, которые возвращает `insert`.

```c
auto [iterator, is_inserted] = accounts.insert({"Jeff"s, 100});
//1. **`iterator` будет указывать на существующий элемент** с ключом `"Jeff"`
if (is_inserted) {
    std::cout << "Ключ добавлен"s << std::endl;
} 
```

Первая переменная (`iterator`) содержит итератор, указывающий на позицию вставленного элемента. Вторая (`is_inserted`) — флаг, принимающий значение `true` в случае удачной вставки.

## А есть?
Самый простой способ проверить ключ — использовать метод `contains`, который возвращает `true` или `false`.

```
if (accounts.contains("Jeff")) {
    // Обрабатываем элемент accounts["Jeff"s].
} else {
    std::cout << "Аккаунт не найден"s << std::endl;
} 
```

лучше использовать метод `find`. Он не только ищет указанный элемент, но и возвращает итератор на его позицию, который затем можно использовать для доступа. Если искомого элемента нет, итератор будет указывать на позицию после последнего элемента `std::map`, то есть будет равен итератору `end`.

```c
auto iterator = accounts.find("Mary"s); 
//ищет элемент **по ключу** в контейнере `accounts`.
if (iterator != accounts.end()) { 
  std::cout << "Элемент есть в словаре"s << std::endl;
  
  // Обрабатываем элемент через итератор.
  int user_number = iterator->second;
} 
```

**перегруженные операции сравнения** позволяют сравнивать словари целиком в соответствии с их элементами.

```
std::map<std::string, uint64_t> old_accounts {
    {"Annie"s, 9859489},
};

std::map<std::string, uint64_t> new_accounts {
    {"Annie"s, 10000},
};

if (old_accounts != new_accounts) {
    std::cout << "Словари не одинаковые"s << std::endl;
} 
```

## swap.
 Он позволяет менять местами содержимое двух словарей. На практике эта операция требуется не так часто, как другие, однако её полезно иметь в своём арсенале. При необходимости лучше использовать встроенные методы, поскольку они работают гораздо эффективнее. Например, `swap` перемещает словари как структуры, а не по элементам, благодаря чему нет лишних операций копирования и сложность операции не зависит от размера словаря.
```c
 std::map<std::string, uint64_t> old_accounts {
    {"Annie"s, 9859489},
};

std::map<std::string, uint64_t> new_accounts {
    {"Martha"s, 10000},
    {"Mary"s, 1055515},
};

ShowAccounts(old_accounts); // Annie, 9859489.
ShowAccounts(new_accounts); // Martha, 10000, Mary, 1055515.

old_accounts.swap(new_accounts); // Меняем словари местами.

ShowAccounts(old_accounts); // Martha, 10000, Mary, 1055515.
ShowAccounts(new_accounts); // Annie, 9859489.
```

